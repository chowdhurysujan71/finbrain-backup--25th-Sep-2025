Awesome â€” hereâ€™s a **single, copy-paste Replit AI Agent prompt** to implement the **policy-safe â€œRemind me tomorrowâ€ micro-nudge**. Itâ€™s additive, respects your **always\_on\_v1** architecture, avoids Facebookâ€™s 24-hour violation by scheduling a **single, user-initiated reminder within \~23 hours**, and needs **no cron or DB migrations** (uses your existing TTL store pattern with Redis â†’ in-proc fallback).

---

# Replit Agent Task â€” FinBrain â€œRemind Me Tomorrowâ€ (Policy-Safe, Always-On)

You are editing the FinBrain repo. Make **additive** changes only. **Do not** rename/move files or change public interfaces. Preserve the pipeline:

**FAQ fast-path â†’ (post-FAQ) Guardrails v2 â†’ Limiter â†’ RL-2 (if limited) â†’ AI (if enabled) â†’ Dispatcher/Handlers**

## Goals

* Implement **user-initiated** one-shot reminder:

  * User: â€œremind me tomorrowâ€ â†’ schedule a **single** check-in \~23h later.
  * Bot (at \~23h): â€œğŸŒ™ Evening check-in: Did you have any expenses today you want me to log?â€
  * User: â€œstop reminderâ€ â†’ cancel pending reminder.
* **No cron, no DB migrations**. Use TTL store (Redis if available, otherwise in-proc fallback).
* **Messenger policy-safe**: Messages only within 24h of the prior interaction (schedule at **23h**).
* Respect guardrails: **one bubble, â‰¤280 chars, â‰¤2 emojis**, non-promotional.

## Files in scope

* `utils/ux_copy.py` (append copy)
* `utils/ttl_store.py` (import & reuse; no edits required)
* `utils/intent_router.py` (add 2 minimal intents)
* `utils/dispatcher.py` (route the two intents)
* `handlers/reminder.py` (**new**) â€” schedule/cancel + background timer
* `utils/production_router.py` (**read-only**; no reordering)

## Non-negotiables

* **No feature flags** (fits always\_on\_v1).
* **No new routes** and **no exports**.
* **No DB schema changes**.
* **Fail-open**: if scheduling fails, reply kindly and continue.

---

## PART 1 â€” UX copy (append to `utils/ux_copy.py`)

Add these constants (donâ€™t modify existing ones):

```python
REMIND_CONFIRM   = "â° Got it! Iâ€™ll check in around this time tomorrow. You can say â€˜stop reminderâ€™ anytime."
REMIND_ALREADY   = "â³ You already have a check-in scheduled. Iâ€™ll ping you tomorrow."
REMIND_SENT      = "ğŸŒ™ Evening check-in: Did you have any expenses today you want me to log?"
REMIND_CANCELLED = "âœ… Got it â€” Iâ€™ll skip tomorrowâ€™s check-in. Say â€˜remind me tomorrowâ€™ to start again."
REMIND_ERROR     = "ğŸ§­ I couldnâ€™t set a reminder just now, but you can always message me to log anytime."
```

---

## PART 2 â€” Intent detection (edit `utils/intent_router.py`)

Add two safe, deterministic intents. **Do not touch â€œstatusâ€** (reserved for DIAGNOSTIC).

```python
text_l = (text or "").lower()

# Reminders (user-initiated, policy-safe)
if "remind me tomorrow" in text_l or "remind tomorrow" in text_l:
    return Intent.REMIND_TOMORROW

if "stop reminder" in text_l or "cancel reminder" in text_l:
    return Intent.STOP_REMINDER
```

Add the corresponding enum members if your code uses an enum:

```python
class Intent(Enum):
    ...
    REMIND_TOMORROW = "REMIND_TOMORROW"
    STOP_REMINDER   = "STOP_REMINDER"
```

---

## PART 3 â€” Dispatcher wiring (edit `utils/dispatcher.py`)

Route to the new handler (additive; leave other paths untouched):

```python
from handlers import reminder as reminder_handler

...
if intent == Intent.REMIND_TOMORROW:
    return reminder_handler.schedule_reminder(ctx)  # returns a short UX message

if intent == Intent.STOP_REMINDER:
    return reminder_handler.cancel_reminder(ctx)
```

> `ctx` should expose `user_id` (PSID or hash) and `now_utc`/message time if available; if not, read `datetime.utcnow()` inside the handler.

---

## PART 4 â€” New handler (create `handlers/reminder.py`)

Implements policy-safe, one-shot scheduling using your TTL store. Uses **23 hours** (not 24) to stay inside the Free 24-Hour Window.

```python
import os
import threading
import datetime
from typing import Optional

from utils.ux_copy import (
    REMIND_CONFIRM, REMIND_ALREADY, REMIND_SENT, REMIND_CANCELLED, REMIND_ERROR
)
from utils.ttl_store import get_store

# Config: 23 hours to respect FB 24h policy window
REMIND_DELAY_SECONDS = int(os.getenv("REMIND_DELAY_SECONDS", str(23 * 3600)))
REMIND_TTL_SECONDS   = int(os.getenv("REMIND_TTL_SECONDS",   str(23 * 3600 + 900)))  # small buffer

# In-proc timer registry (best-effort; Redis is the source of truth)
_timers = {}  # key: user_id, value: threading.Timer

def _send_message_to_user(user_id: str, text: str):
    """
    TODO: call your existing Messenger Send API wrapper.
    Keep it short; one bubble; â‰¤2 emojis.
    """
    try:
        # Example: messenger.send_text(user_id, text)
        pass
    except Exception:
        # Swallow errors; reminders must never crash pipeline
        pass

def _timer_fire(user_id: str):
    """
    Fires when the timer elapses; double-checks the Redis key to
    avoid duplicate sends after restarts or cancellations.
    """
    store = get_store()
    key = f"remind:one:{user_id}"
    try:
        if store.exists(key):
            _send_message_to_user(user_id, REMIND_SENT)
            # Clear after sending so user can schedule again
            store.setex(key, 1, "sent")  # short TTL to mark completion
    finally:
        _timers.pop(user_id, None)

def schedule_reminder(ctx) -> str:
    """
    Schedules a one-shot reminder ~23h from now for this user.
    No DB writes; Redis key + in-proc Timer (best effort).
    """
    user_id = str(ctx.user_id)
    store = get_store()
    key = f"remind:one:{user_id}"

    try:
        # If a reminder exists, avoid scheduling duplicates
        if store.exists(key):
            return REMIND_ALREADY

        # Set a TTL key as the source of truth
        store.setex(key, REMIND_TTL_SECONDS, "pending")

        # Schedule in-proc timer (best-effort; instance restarts may skip firing)
        if user_id in _timers:
            try:
                _timers[user_id].cancel()
            except Exception:
                pass
        t = threading.Timer(REMIND_DELAY_SECONDS, _timer_fire, args=(user_id,))
        t.daemon = True
        t.start()
        _timers[user_id] = t

        return REMIND_CONFIRM
    except Exception:
        # Fail-open: never block user flows
        return REMIND_ERROR

def cancel_reminder(ctx) -> str:
    """
    Cancels a scheduled reminder if present.
    """
    user_id = str(ctx.user_id)
    store = get_store()
    key = f"remind:one:{user_id}"

    try:
        # Clear TTL key
        if store.exists(key):
            store.setex(key, 1, "cancelled")  # expire quickly

        # Cancel in-proc timer if running
        if user_id in _timers:
            try:
                _timers[user_id].cancel()
            except Exception:
                pass
            finally:
                _timers.pop(user_id, None)

        return REMIND_CANCELLED
    except Exception:
        return REMIND_CANCELLED  # quiet success for UX
```

**Notes**

* **Policy-safe**: The reminder is **explicitly user-initiated** and **fires within \~23h** of that interaction.
* **No cron needed**: We use a **daemon `threading.Timer`** for best-effort delivery. Redis key is the truth; if the VM restarts, the reminder may be lost â€” acceptable for MVP.
* **Spam control**: Only one active reminder per user (`remind:one:{user_id}`).

---

## PART 5 â€” UAT (10â€“15 min)

**Setup:** No new env needed (defaults work). Optionally set:

```
REMIND_DELAY_SECONDS=10      # for fast testing
REMIND_TTL_SECONDS=60
```

**Scenarios**

1. **Schedule**

   * User: `remind me tomorrow`
   * Bot: `â° Got it! Iâ€™ll check in around this time tomorrowâ€¦`
   * Wait 10s (with test env) â†’ Bot sends: `ğŸŒ™ Evening check-in: Did you have any expenses today you want me to log?`

2. **Duplicate protection**

   * User: `remind me tomorrow` (twice)
   * Second reply: `â³ You already have a check-in scheduledâ€¦`

3. **Cancel**

   * User: `stop reminder`
   * Bot: `âœ… Got it â€” Iâ€™ll skip tomorrowâ€™s check-inâ€¦`
   * Ensure no reminder is sent after the delay.

4. **Fail-open**

   * Temporarily break send path (simulate exception) â†’ handler still returns text; app doesnâ€™t crash.

5. **Guardrails**

   * All messages are â‰¤280 chars, â‰¤2 emojis, one bubble.
   * No links/files; content is non-promotional.

**Policy check**

* The scheduled message is **user-initiated** and **within 24h** â†’ compliant.

---

## End-of-Run Report (fill after UAT)

**Build:** `<commit>`
**Date (UTC+6):** `<YYYY-MM-DD>`
**Tester:** `<name>`

### Summary

* âœ… â€œRemind me tomorrowâ€ schedules a single check-in (\~23h) via TTL + in-proc timer.
* âœ… â€œStop reminderâ€ cancels pending reminder.
* âœ… No cron, no DB migrations, no router reordering.
* âœ… Messages comply with Messengerâ€™s 24-hour rule and UX guardrails.

### Evidence

* Log snippets showing schedule â†’ fire â†’ cancel.
* Screenshots of user flows.

### Issues

* `<none / list>`

### Go/No-Go

* **GO / NO-GO** â€” Sign-off: `<name>`

---

### Why this is safe

* **Policy-compliant** (user-initiated, inside 24h).
* **Architecture-aligned** (always\_on\_v1, additive, no schema changes).
* **Operationally simple** (Redis key + one Timer; best-effort).
* **Reversible** (remove intents/routes to disable; no data migration).

If you later add a durable scheduler (e.g., Cloud Tasks, n8n, or a tiny worker on Redis KEYEVENTS), you can upgrade delivery reliability without changing the UX or intents.
