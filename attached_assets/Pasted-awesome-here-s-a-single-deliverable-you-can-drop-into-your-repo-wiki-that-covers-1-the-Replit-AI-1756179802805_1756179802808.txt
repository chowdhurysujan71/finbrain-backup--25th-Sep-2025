awesome—here’s a single deliverable you can drop into your repo/wiki that covers **(1) the Replit AI agent system prompt**, **(2) a step-by-step build plan**, **(3) UAT assurance**, and **(4) end-to-end testing & reporting**—all written with your core foundation constraints in mind: **production-architecture alignment, zero core-system risk, and no surprises.**

---

# Replit AI Agent — System Prompt (copy-paste)

```
SYSTEM: You are the AI Interpretation Layer for **finbrain** (always lowercase).
Goal: transform every user message into ONE strict **Canonical Command (CC)**
JSON that is deterministic, auditable, and SAFE for the core system.

!!! ABSOLUTE INVARIANTS (MUST NEVER BE BROKEN) !!!
- Never overwrite or delete the raw ledger; only append.
- Never emit free-form chat; return EXACTLY ONE JSON object per message.
- Never trigger outbound notifications; all interactions are user-initiated.
- Fail CLOSED: on uncertainty or parsing error, produce a CC with decision="RAW_ONLY" (if amount detected) or intent="HELP".
- Determinism: same input → same output. No randomness.
- PII-safety: mirror user text only in `source_text`; do not add PII fields you cannot justify.

--------------------------------
FEATURE FLAGS (read-only inputs)
--------------------------------
- mode: "FALLBACK" | "SHADOW" | "DRYRUN" | "ON"
  * FALLBACK: agent output is ignored by backend; legacy path runs. Still produce CC for audit.
  * SHADOW: produce CC + snapshot only; backend writes NOTHING new.
  * DRYRUN: backend writes immutable RAW only (no overlays); testers see "would apply".
  * ON: backend writes overlays per decision policy.
- tau_high (default 0.85), tau_low (default 0.55) for confidence gating.
- slo_budget_ms (default 600). If reasoning would exceed this, degrade to "RAW_ONLY" or "HELP".

--------------------------------
CANONICAL COMMAND (CC) — STRICT SCHEMA
--------------------------------
Your entire output MUST be ONE JSON object with EXACT keys:

{
  "schema_version": "pca-v1",
  "cc_id": "<uuid-like string>",               // idempotency key (backend may replace "auto")
  "schema_hash": "<short stable hash of keys>",// to help backend validate schema integrity
  "user_id": "<string-or-unknown>",
  "intent": "LOG_EXPENSE" | "CORRECT" | "RELABEL" | "VOID" | "QUERY" | "TRANSFER_BUDGET" | "REFUND" | "SUBSCRIPTION_ACTION" | "HELP",
  "slots": {
    "amount": <number|null>,
    "currency": "<ISO|null>",
    "time_expr": "<string|null>",              // e.g., "yesterday 8pm"
    "time_abs": "<ISO 8601|null>",             // may be null; backend resolves
    "merchant_text": "<string|null>",
    "merchant_id": "<string|null>",            // null if unresolved
    "category": "<string|null>",
    "subcategory": "<string|null>",
    "account": "<string|null>",
    "person": "<string|null>",
    "period": "<string|null>",                 // "this week", "Q3", "Eid week"
    "note": "<string|null>",

    // Multi-item input support (optional):
    "items": null | [ { "amount": <number>, "currency": "<ISO|null>", "time_expr": "<string|null>", "merchant_text": "<string|null>", "category": "<string|null>", "note": "<string|null>" } ],

    // For CORRECT (targeting) and RELABEL (rules):
    "target": { "transaction_id": "<string|null>", "natural_ref": "<string|null>" },
    "pattern": { "merchant": "<string|null>", "vertical": "<string|null>", "store_name_contains": "<string|null>", "text_contains": "<string|null>", "category_was": "<string|null>" },
    "rule_set": { "category": "<string|null>", "subcategory": "<string|null>" },

    // Subscriptions and budgets:
    "subscription_action": "<cancel|pause|change_plan|null>",
    "transfer": { "source_budget": "<string|null>", "dest_budget": "<string|null>", "amount": <number|null> }
  },

  "confidence": <0.0..1.0>,                    // calibrated number you stand behind
  "decision": "AUTO_APPLY" | "ASK_ONCE" | "RAW_ONLY",
  "clarifier": {
    "type": "<category_pick|which_object|time_confirm|none>",
    "options": [ "<option1>", "<option2>", "<option3>", "Other" ],
    "prompt": "<<=80 chars or empty>"
  },

  "source_text": "<verbatim user message>",
  "model_version": "<string>",
  "ui_note": "<=140 chars; short human-friendly confirmation>"
}

STRICT RULES:
- EXACT keys only; null for unknowns. No comments, no trailing commas.
- If a money event is present (amount detected), you MUST enable safe persistence by providing sufficient slots.
- Decision policy:
  - If confidence >= tau_high → "AUTO_APPLY".
  - If tau_low <= confidence < tau_high → "ASK_ONCE" with a single best clarifier.
  - If confidence < tau_low but amount exists → "RAW_ONLY" (backend logs immutable raw with category unknown).
- For ambiguous corrections, set "target.natural_ref" (e.g., "the lunch just logged").
- For anything outside scope → intent="HELP" with `ui_note` explaining limits.
- NEVER imply or require outbound notifications.

--------------------------------
SAFETY & AUDIT
--------------------------------
- Always set "schema_version" and "schema_hash" (e.g., SHA-1 of ordered key names).
- Always fill "source_text".
- Your output must be reproducible and within slo_budget_ms; if not, degrade to RAW_ONLY/HELP.
- Your "ui_note" reflects the decision, e.g.:
  - LOG_EXPENSE/AUTO_APPLY: "Logged ৳500 food at 'Cheez' (yesterday)."
  - LOG_EXPENSE/ASK_ONCE: "Looks like groceries—pick one to confirm."
  - LOG_EXPENSE/RAW_ONLY: "Saved ৳500; category to confirm."
  - CORRECT: "Updated: food → entertainment (your view)."
  - RELABEL: "Rule set: 'Mart' → groceries (future)."
  - VOID: "Voided in your view; raw kept."
  - HELP: "finbrain logs and corrects expenses; ask me to fix or show a report."

--------------------------------
ILLUSTRATIVE EXAMPLES (concise)
--------------------------------
User: "Starbux 780 yesterday"
→ intent=LOG_EXPENSE, category=coffee, confidence~0.93 → decision=AUTO_APPLY

User: "bkash 500"
→ intent=LOG_EXPENSE, low certainty → decision=ASK_ONCE with options ["utilities","fees","other","Other"]

User: "change that lunch to entertainment"
→ intent=CORRECT, target.natural_ref="the lunch just logged", decision=AUTO_APPLY

User: "delete that wrong entry"
→ intent=VOID, target.natural_ref filled, decision=AUTO_APPLY

User: "cancel netflix"
→ intent=SUBSCRIPTION_ACTION with subscription_action="cancel", decision=ASK_ONCE if multiple candidates
```

---

# Step-by-Step Build Plan (risk-first, aligned to your foundation feedback)

**Guiding principles**

* Zero core risk: existing `transactions_raw` remains append-only and untouched.
* Everything new is **overlay + flags**.
* Deterministic agent + auditable snapshots.
* FB policy-safe (no outbound pings).

## Phase 0 — Safety Rails Online (Day 0–1)

* **Flags in codepath:** `FALLBACK` (default), `SHADOW`, `DRYRUN`, `ON`.
* **Global kill switch:** env toggle forces `FALLBACK` in all handlers.
* **Idempotency:** derive `cc_id` = stable hash(user\_id + message\_id + ts + text); backend de-dupes.

**Exit checks**

* Toggling any flag does not alter current production behavior (because `FALLBACK` by default).
* Health endpoint exposes current flag values.

## Phase 1 — Overlay Schema (Day 1–2)

Create additive tables (no migrations on core ledger):

* `transactions_effective(tx_id, user_id, category, subcategory, merchant_id, status, decided_by, decided_at)`
* `user_corrections(corr_id, tx_id, user_id, fields_json, reason, created_at)`
* `user_rules(rule_id, user_id, pattern_json, set_json, scope, created_at)`
* `inference_snapshot(cc_id, user_id, intent, slots_json, confidence, decision, clarifier_json, model_version, created_at)`

**Exit checks**

* Backward-compatible deploy; legacy reads/writes unaffected.
* Rollback plan documented (drop overlays with no side effects).

## Phase 2 — Agent Integration in SHADOW (Day 3)

* Route every inbound message to agent (prompt above).
* Persist **only** `inference_snapshot`.
* Do not write overlays; do not change user responses.

**Exit checks**

* 100% messages produce valid CC JSON (schema-validated).
* No schema exceptions; p95 agent latency < 600ms.

## Phase 3 — Confidence & Clarifier Policy (Day 4–5)

* Implement decision gates (`tau_high`, `tau_low`) in the decision wrapper.
* Clarifier inventory: `category_pick`, `which_object`, `time_confirm`.
* Switch to **DRYRUN**: backend writes immutable RAW (when amount present); overlays still not written; internal testers see "would apply".

**Exit checks**

* Ask-rate on ambiguous inputs 10–25%.
* 100% money events create RAW in DRYRUN; zero duplicates (idempotency passes).

## Phase 4 — Overlays + Audit Surfacing (Day 6)

* Turn `ON` for internal canary (≤100 users).
* Write `transactions_effective` / `user_corrections` per CC `decision`.
* UI: show **“Original vs Corrected (your view)”** in chat.
* Read precedence: corrections > rules > model > defaults > unknown.

**Exit checks**

* Corrections apply instantly to user view; no cross-user bleed (A/B isolation test).
* Audit row visible for any corrected entry.
* Flip back to `FALLBACK` returns system to pre-PCA behavior with no data loss.

## Phase 5 — Production-style Observability (Day 6–7)

* Metrics: error rate, p50/p95/p99 latency, ask-rate, correction-rate, RAW write success.
* Structured logs: include `cc_id`, `schema_version`, `model_version`, decision.
* Alerts: error rate > 0.5%, p95 > 900ms, RAW write success < 100%.

**Exit checks**

* Dashboards reviewed daily during canary; alerting verified by synthetic trip.

---

# UAT Assurance Plan (must hit 100% pass on scope)

**Scopes derived from your gaps & team feedback**

1. **User-level correction isolation**

* UAT-A1: User A corrects “Lunch → Entertainment”; User B’s view unaffected.
* UAT-A2: User A rule applies only to User A’s new entries.

2. **Audit transparency**

* UAT-B1: After correction, chat shows “Original vs Corrected (your view)”.
* UAT-B2: “Show raw details” reveals immutable entry.

3. **Confidence handling + clarifier**

* UAT-C1: Ambiguous (“bkash 500”) triggers one chip; choice updates effective.
* UAT-C2: No response to chip → RAW only; later correction works.

4. **Feature flags / kill switch**

* UAT-D1: Flip to `FALLBACK` mid-session; legacy path resumes; no data loss.
* UAT-D2: `SHADOW` logs snapshots only; `DRYRUN` writes RAW only; `ON` writes overlays.

5. **Canonical Command (snapshot + determinism)**

* UAT-E1: Replaying same message produces identical CC.
* UAT-E2: Snapshots retained; schema\_version/hash validated.

6. **Overlay schema separation**

* UAT-F1: Raw table never mutated; overlays only. Checksums match pre/post test.
* UAT-F2: Voids change only effective status; raw preserved.

7. **Engagement basics (policy-safe)**

* UAT-G1: “report”, “this week vs last”, “top 3 merchants” render from overlays.
* UAT-G2: No outbound nudges are sent (policy guard).

**UAT Exit Criteria (absolute)**

* 100% of the above test cases pass.
* Zero Sev-1/2 defects; Sev-3 only with accepted mitigation (and flags default to `FALLBACK` for affected path).
* RAW write success = 100% on all money-event tests.
* Cross-user isolation verified.

---

# End-to-End System Testing (pre-prod + canary)

## Pre-Prod Dry Run (record-and-replay)

* Corpus: ≥1,000 real-style messages (EN/BN mixed; multi-expense; corrections; rules; queries).
* Run twice: `SHADOW` then `DRYRUN`.
  **Pass bars**
* Coverage: 100% messages produce valid CC.
* Money capture: 100% messages with amount create RAW (DRYRUN).
* No schema/validation errors.

## Load & Reliability

* Burst 50 rps for 60s, sustained 10 rps for 10 min.
* Inject 5% agent timeouts; verify `FALLBACK` engaged and user path unaffected.
* p50 ≤ 250ms; p95 ≤ 900ms; p99 ≤ 1500ms end-to-end.

## Data Integrity

* Ledger immutability checksums pre/post.
* Overlay reconciliation = legacy totals on high-confidence paths.

## Security/Privacy

* Logs contain `cc_id`, not PII; `source_text` only where essential.
* Snapshot TTL policy (e.g., 90 days) verified.

## Canary Monitoring (prod-like)

* Cohort ≤100 users on `ON`.
* Daily review: error rate (<0.5%), RAW success (100%), ask-rate (10–25%), correction-rate trending down, p95 latency (<900ms).
* Rollback drill: flip to `FALLBACK`, confirm instant reversion.

---

# Test Report Template (fill during UAT/E2E)

**Title:** PCA MVP Validation — <date range>
**Build/Versions:** app SHA, model\_version, schema\_version
**Flags Used:** SHADOW/DRYRUN/ON/FALLBACK (with timestamps)
**Scope:** UAT cases A1–G2; E2E load/chaos/data-integrity

**Results Summary**

* UAT: XX/XX pass (100% required)
* E2E: latency p50/p95/p99; RAW success; error rate; ask-rate
* Incidents: list with RCA, mitigation, flag posture
* Data Integrity: raw checksums matched; overlays-only mutations verified
* Policy: outbound messaging = 0

**Go/No-Go Decision:** GO / NO-GO
**Sign-offs:** PM, CTO/Eng Lead, QA Lead
**Rollback Readiness:** validated (timestamp), `FALLBACK` tested live

---

# Production-Architecture Alignment (why this won’t break your system)

* **Core immutability:** `transactions_raw` remains append-only; never updated.
* **Overlay-only writes:** user truth lives in `transactions_effective` & `user_corrections`; rules in `user_rules`.
* **Deterministic agent:** JSON-only CC, schema\_version/hash, idempotent `cc_id`.
* **Gated rollout:** SHADOW → DRYRUN → ON (canary) with instant `FALLBACK`.
* **Observability:** metrics, logs, alerts bound to strict SLOs; chaos tested.
* **FB policy-safe:** no outbound messages; all clarifiers are user-initiated chips.
* **Security posture:** minimal PII in logs; snapshot TTL; audit trail for every decision.

---

## Definition of Done (must all be true)

1. 100% UAT scope pass; 0 Sev-1/2 defects.
2. 100% RAW write success for money-event inputs in DRYRUN and ON.
3. Audit UI live (“Original vs Corrected (your view)”).
4. Clarifier flow live; ask-rate 10–25%; correction-rate improving week-over-week.
5. p95 latency < 900ms; error rate < 0.5% during canary.
6. Rollback drill executed; `FALLBACK` restores legacy instantly.
7. Final signed test report; staged plan for gradual cohort expansion.

---

If you want this turned into a one-pager PDF + a checklist your team can literally tick off during the sprint, say the word and I’ll package it for you.
