What it is (PM in one line)

A safe, add-on data layer that lets finbrain show each user their corrected truth without ever touching the raw, append-only ledger.

User value (PM)

Trust: “What I said is stored forever; what I see reflects my corrections.”

Control: Fix a category once; see it everywhere in your view.

Clarity: Tap any entry to see Original vs Corrected (your view).

No surprises: If the AI is unsure, your data still logs safely; you can correct later.

Product surface (PM)

Audit row in chat & reports:

Original: Lunch, Food, ৳500 (Aug 25, 8:12 PM)

Effective (your view): Entertainment (rule applied on Sept 1)

“Apply as a rule” chip: Turn one correction into a per-user rule, retroactively (optional) and for future.

Consistent reports: Monthly totals and category charts always use your effective view.

What changes in data (CTO)

We do not change existing tables or flows that write raw records. We add three tables and a read-time precedence:

New additive tables

transactions_effective — current, user-specific truth per transaction

tx_id, user_id, category, subcategory, merchant_id, status (active|voided), decided_by (model|user|rule), decided_at

user_corrections — user’s field fixes for specific transactions

corr_id, tx_id, user_id, fields_json, reason, created_at

user_rules — user’s pattern rules (e.g., “merchant contains ‘Mart’ → groceries”)

rule_id, user_id, pattern_json, set_json, scope (future_only|past_and_future), created_at

Read-time precedence (deterministic)

When showing anything to a user:

User correction (newest wins, per field)

Matching user rules (ordered by recency/specificity)

Model decision (if present)

Weak defaults (taxonomy)

Fallback: category=unknown

Result: The ledger never changes; the view does—safely, per user.

How it works end-to-end (PM + CTO)

User logs “Lunch 500 at Cheez.”

Raw ledger gets a row (as today).

If high confidence, we also write an effective row for that user.

User corrects: “Actually entertainment.”

We create a user_corrections row and update transactions_effective for that user only.

Audit row shows Original vs Effective immediately.

User taps “Apply as a rule.”

We add a user_rules entry. Future (and optionally past) matching items are rendered as Entertainment for that user—no ledger edits.

Why this won’t break anything (CTO)

Raw immutability: We never update or delete ledger rows.

Additive schema only: New tables; no migration on existing columns.

Compatibility: Legacy endpoints keep working; overlay is opt-in at read-time.

Instant rollback: A single feature flag disables overlay reads; product reverts to legacy views with no data loss.

Idempotency: Each write keyed by a command id; no double-applies.

Rollout plan (PMO view; minimal blast radius)

Day 1–2 – Ship tables (no reads yet): Deploy transactions_effective, user_corrections, user_rules. Nothing changes user-visible behavior.

Day 3 – Shadow compute: Populate effective rows in the background; still render legacy views. Compare totals silently.

Day 4 – Internal DRYRUN: A toggle shows audit rows only to testers; production users remain on legacy.

Day 5 – Canary ON: 50–100 users see overlay views. Kill switch ready.

Day 7+ – Gradual ramp: 10% → 25% → 50% → 100%, with health gates.

Success metrics (PM + Data)

Trust/Accuracy:

100% money events logged in raw (unchanged).

Cross-user bleed = 0 (a correction for User A never changes User B).

UX:

Audit row seen on ≥70% of corrections.

Clarifier answer rate 60–80%; correction rate trending down week-over-week.

Reliability:

p95 render latency < 900 ms with overlay.

Overlay read error rate < 0.5%; fallback invocations traced.

Data integrity:

Raw ledger checksums identical pre/post launch.

UAT scope (must pass 100%)

Isolation: A corrects; B unaffected. A rule applies only to A.

Audit: Chat shows Original vs Effective immediately after a correction.

Reports: Monthly totals reflect effective view; toggling overlay off returns legacy totals exactly.

Voids: Voiding sets status=voided in effective; raw untouched.

Edge cases: Multi-expense messages; code-mixed BN/EN; ambiguous category (clarifier once); idempotent replays.

Flags: SHADOW/DRYRUN/ON/FALLBACK switch cleanly mid-session.

Risks & mitigations (CTO)

Risk: Incorrect overlay logic changes totals.

Mitigation: Shadow compare (raw+legacy vs raw+overlay) before canary; block release if delta > tolerance.

Risk: Performance regression from overlay joins.

Mitigation: Index on (user_id, tx_id, decided_at); cache per-period effective aggregates; keep p95 < 900 ms.

Risk: Rule over-application.

Mitigation: Specificity ordering + preview count before confirm; easy disable per rule.

“Explain it to an exec” (PM)

Before: One table tries to be both truth and preference—hard to trust.

After: Truth (raw) is sacred; preference (effective) is layered on top, per user. Users see exactly what changed and why. If anything misbehaves, we flip a switch and you’re back to today’s behavior—no data lost.