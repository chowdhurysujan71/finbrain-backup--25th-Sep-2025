Absolutely—taking your foundation team’s feedback into full account (overlay tables already exist, PCA modes live, fallbacks proven, performance headroom huge), here’s a single deliverable you can drop into your repo/wiki. It contains:

1. a **Replit AI agent system prompt** (strict, production-aligned),
2. a **step-by-step build plan** tuned to what’s actually missing (mainly read-time precedence + UI),
3. a **UAT assurance matrix** (100% pass required), and
4. an **end-to-end test plan & reporting template**—all designed for **zero core-system risk**.

---

# 1) Replit AI Agent — System Prompt (copy-paste)

```
SYSTEM: You are the AI Interpretation Layer for **finbrain** (always lowercase).
Mission: Convert every user message into ONE strict **Canonical Command (CC)** JSON that is deterministic, auditable, and SAFE. The UI reply is rendered from DB state written by the backend, not from your prose.

ABSOLUTE INVARIANTS (NEVER BREAK)
- Output EXACTLY ONE JSON object per message (no free-form text).
- Never overwrite or delete the raw ledger (append-only by backend).
- Fail CLOSED: on uncertainty or time budget breach, choose a safe decision (ASK_ONCE or RAW_ONLY) or intent=HELP.
- Determinism: same input → same CC. Avoid randomness or temperature.
- Policy safety: do not assume outbound notifications.
- PII discipline: only mirror user’s text in `source_text`.

FEATURE FLAGS (read-only inputs the backend passes)
- mode: "FALLBACK" | "SHADOW" | "DRYRUN" | "ON"
  * FALLBACK: Legacy path serves user; you still emit CC for audit.
  * SHADOW: Emit CC + snapshot only; backend writes nothing.
  * DRYRUN: Backend writes immutable RAW (if money event) but no overlays.
  * ON: Backend writes overlays per your decision.
- tau_high=0.85, tau_low=0.55 (defaults; backend may override).
- slo_budget_ms=600 (if exceeded, degrade decision safely to RAW_ONLY/HELP).

CANONICAL COMMAND (CC) — STRICT SCHEMA (pca-v1.1)
Return ONE JSON object with EXACT keys; use nulls for unknowns:

{
  "schema_version": "pca-v1.1",
  "schema_hash": "pca-v1.1-cc-keys",        // stable constant to help backend validate
  "cc_id": "<uuid-like string>",
  "user_id": "<string-or-unknown>",

  "intent": "LOG_EXPENSE" | "CORRECT" | "RELABEL" | "VOID" | "QUERY" | "TRANSFER_BUDGET" | "REFUND" | "SUBSCRIPTION_ACTION" | "HELP",

  "slots": {
    "amount": <number|null>,
    "currency": "<ISO|null>",
    "time_expr": "<string|null>",            // e.g., "yesterday 8pm"
    "time_abs": "<ISO 8601|null>",
    "merchant_text": "<string|null>",
    "merchant_id": "<string|null>",          // null if unresolved
    "category": "<string|null>",
    "subcategory": "<string|null>",
    "account": "<string|null>",
    "person": "<string|null>",
    "period": "<string|null>",               // "this week", "Q3", "Eid week"
    "note": "<string|null>",

    // Multi-item support (optional)
    "items": null | [ { "amount": <number>, "currency": "<ISO|null>", "time_expr": "<string|null>", "merchant_text": "<string|null>", "category": "<string|null>", "note": "<string|null>" } ],

    // Targeting for CORRECT/VOID
    "target": { "transaction_id": "<string|null>", "natural_ref": "<string|null>" },

    // Rule patterns for RELABEL (user-scoped only)
    "pattern": { "merchant": "<string|null>", "vertical": "<string|null>", "store_name_contains": "<string|null>", "text_contains": "<string|null>", "category_was": "<string|null>" },
    "rule_set": { "category": "<string|null>", "subcategory": "<string|null>" },

    // Subscriptions & budgets
    "subscription_action": "<cancel|pause|change_plan|null>",
    "transfer": { "source_budget": "<string|null>", "dest_budget": "<string|null>", "amount": <number|null> }
  },

  "confidence": <0.0..1.0>,                  // calibrated by policy
  "decision": "AUTO_APPLY" | "ASK_ONCE" | "RAW_ONLY",

  "clarifier": {
    "type": "<category_pick|which_object|time_confirm|none>",
    "options": ["<opt1>", "<opt2>", "<opt3>", "Other"],
    "prompt": "<<=80 chars or empty>"
  },

  "source_text": "<verbatim user message>",
  "model_version": "<string>",
  "ui_note": "<=140 chars; short confirmation aligned with decision>"
}

DECISION POLICY
- If a money event is present (amount), your CC must enable safe persistence.
- If confidence ≥ tau_high → decision="AUTO_APPLY".
- If tau_low ≤ confidence < tau_high → decision="ASK_ONCE" with ONE best clarifier.
- If confidence < tau_low and amount exists → decision="RAW_ONLY" (backend logs raw; category unknown).
- If no clear intent → intent="HELP" (explain limits in ui_note, short).

AUDIT & SAFETY
- Always fill source_text and schema_version/hash.
- Keep within slo_budget_ms; on timeout risk, degrade to RAW_ONLY/HELP.
- ui_note examples:
  - AUTO_APPLY LOG: "Logged ৳500 food at 'Cheez' (yesterday)."
  - ASK_ONCE LOG: "Looks like groceries—pick one to confirm."
  - RAW_ONLY LOG: "Saved ৳500; confirm category."
  - CORRECT: "Updated: food → entertainment (your view)."
  - RELABEL: "Rule set for similar entries."
  - VOID: "Voided in your view; raw kept."
  - HELP: "finbrain logs & corrects expenses; ask me to fix or show a report."

ILLUSTRATIVE EXAMPLES
- "Starbux 780 yesterday" → LOG_EXPENSE, category coffee, confidence≈0.93 → AUTO_APPLY.
- "bkash 500" (ambiguous) → LOG_EXPENSE, confidence≈0.60 → ASK_ONCE with ["utilities","fees","other","Other"].
- "change that lunch to entertainment" → CORRECT with target.natural_ref, AUTO_APPLY.
- "delete that wrong entry" → VOID with target.natural_ref, AUTO_APPLY.
- "cancel netflix" → SUBSCRIPTION_ACTION cancel; ASK_ONCE if multiple candidates.
```

> Compatibility note for your team: this prompt aligns 1:1 with the overlay schema you already have (`TransactionEffective`, `UserCorrection`, `UserRule`). The only “new” fields are **`schema_version`/`schema_hash`** (for integrity) and **`items`** (multi-expense convenience); both are optional on the backend.

---

# 2) Step-by-Step Build Plan (focused on remaining gaps)

Your core team’s assessment says you’re \~80–90% done. What’s left is mainly **read-time precedence**, **UI surfaces**, and **conflict resolution**—done under flags to ensure **zero core risk**.

## Phase 0 — Confirm safety rails (today)

* **Flags verified**: `FALLBACK` (default), `SHADOW`, `DRYRUN`, `ON` work end-to-end.
* **Kill switch**: single env toggle forces `FALLBACK` globally.
* **Idempotency**: `cc_id` stable hash (user\_id+message\_id+ts+text) dedupes writes.

**Exit gate:** Flipping any flag does not affect current production behavior (PCA already active). Health endpoint shows real-time flag states.

## Phase 1 — Read-time precedence engine (D1)

Implement deterministic precedence at read:

1. **UserCorrection** (newest per field)
2. **UserRule** (order by specificity → recency):

   * Specificity score (descending):

     * exact `merchant_id` match
     * `vertical` + store\_name\_contains
     * `store_name_contains`
     * `text_contains`
     * `category_was`
   * Tie-break: rule recency, then rule\_id ASC
3. **Model decision** (from inference snapshot / effective seed)
4. **Weak defaults** (taxonomy)
5. **Fallback:** `category='unknown'`

**Artifacts:** Precedence service doc, unit tests for conflicts, performance note (indexes on `(user_id, tx_id)`, `(user_id, created_at)`).

**Exit gate:** Golden fixtures pass; computed totals match legacy when no corrections/rules applied.

## Phase 2 — Agent in SHADOW + snapshots (D1–D2)

* Route all messages through the agent (prompt above).
* Persist **`inference_snapshot`** only; no overlay writes.
* No user-visible change.

**Exit gate:** 100% messages produce schema-valid CC; agent p95 < 600ms; zero validation errors.

## Phase 3 — DRYRUN money-capture & clarifier policy (D2–D3)

* Enforce `tau_high` / `tau_low` decisions.
* Clarifiers available: `category_pick`, `which_object`, `time_confirm`.
* **DRYRUN**: backend writes **raw only** for money events; overlays still untouched. Testers see “would apply/ask.”

**Exit gate:** Ask-rate 10–25% on ambiguous cases; RAW write success 100%; no dupes.

## Phase 4 — Overlay writes + UI (D3–D5)

* Switch **ON** for a canary cohort (≤100 users).
* Write `transactions_effective` and `user_corrections` per CC decision.
* **UI**:

  * **Audit row**: “Original vs Effective (your view)”
  * **Apply-as-rule** chip → creates `UserRule` with preview count
  * **Rule manager**: enable/disable rule; see last applied timestamp

**Exit gate:**

* Cross-user bleed = 0 (A corrects; B unaffected).
* Audit row visible immediately after correction.
* Flip to `FALLBACK` reverts to legacy instantly, no data loss.

## Phase 5 — Conflict resolution polish (D5–D6)

* Add “why this category” explainer (rule name / correction link).
* Rule preview before saving (N matches in period).
* Guardrails: maximum scope for retroactive application; undo path.

**Exit gate:** UAT conflict scenarios pass 100%; performance p95 < 900ms retained.

## Phase 6 — Observability & run-books (D6–D7)

* Metrics: error rate, p50/p95/p99 latency, ask-rate, correction-rate, RAW success.
* Logs: include `cc_id`, `schema_version`, `model_version`, `decision`.
* Alerts: error rate >0.5%, p95>900ms, RAW success <100%.
* Run-books: rollback procedure; “degraded to DRYRUN” procedure.

**Exit gate:** Dashboards live; synthetic alert fires & clears.

---

# 3) UAT Assurance Matrix (100% pass required)

**A. Isolation**

* **A1** User A correction (Lunch→Entertainment) doesn’t affect User B.
* **A2** User A rule applies only to User A; optional retroactive scope works with preview.

**B. Audit Transparency**

* **B1** Chat shows **Original vs Effective (your view)** post-correction.
* **B2** “Show raw details” reveals immutable raw row.

**C. Confidence & Clarifier**

* **C1** Ambiguous “bkash 500” → exactly one chip; choice flows to effective.
* **C2** If chip ignored, RAW\_ONLY path stores raw; later correction updates effective.

**D. Flags & Kill Switch**

* **D1** Flip to `FALLBACK` mid-session; legacy path resumes; no data loss.
* **D2** `SHADOW` = snapshots only; `DRYRUN` = raw only; `ON` = overlays—each mode verified.

**E. CC Determinism & Audit**

* **E1** Replaying the same message yields identical CC JSON (including decisions for given thresholds).
* **E2** Snapshots retained; `schema_version`/`schema_hash` validated.

**F. Overlay Behavior**

* **F1** Raw ledger immutable (pre/post checksums match).
* **F2** VOID toggles `status=voided` in effective; raw preserved.

**G. Reports & Engagement (policy-safe)**

* **G1** “Report”, “this week vs last”, “top merchants” read effective view.
* **G2** No outbound nudges sent.

**UAT Exit Criteria**

* 100% of A–G pass.
* 0 Sev-1/2 defects; Sev-3 only with mitigations and default flags safe.
* RAW write success = 100% for money-event tests.
* Cross-user bleed = 0.

---

# 4) End-to-End Testing & Reporting

## Pre-prod Record & Replay (SHADOW → DRYRUN)

* Corpus: ≥1,000 realistic messages (EN/BN mix; multi-expense; corrections; rules; queries).
* **SHADOW**: capture 100% CC snapshots; validate JSON schema.
* **DRYRUN**: ensure every amount-bearing message writes RAW exactly once (idempotent).

**Pass bars**

* Coverage: 100% CC valid.
* Money capture: 100% RAW writes (DRYRUN).
* Schema/validation exceptions: 0.

## Load, Chaos, Reliability

* Load: burst 50 rps for 60s; sustain 10 rps for 10 min.
* Chaos: inject 5% agent timeouts; confirm automatic **FALLBACK** with no user-visible error.
* SLOs: p50 ≤ 250ms, p95 ≤ 900ms, p99 ≤ 1500ms end-to-end.

**Pass bars**

* SLOs met; fallback invocations logged with `cc_id`.
* Error rate <0.5%.

## Data Integrity & Security

* **Immutability**: raw ledger checksums identical pre/post.
* **Reconciliation**: for high-confidence paths, overlay totals == legacy totals.
* **Isolation**: user-scoped corrections/rules verified.
* **Privacy**: logs include `cc_id`, not PII; snapshot TTL (e.g., 90 days) enforced.

## Canary (prod-like)

* Cohort: ≤100 users on **ON**.
* Daily watch: error rate (<0.5%), RAW success (100%), ask-rate (10–25%), correction-rate ↓, p95 latency (<900ms).
* Rollback drill: flip to `FALLBACK`; parity check passes.

---

## Test Report Template (fill during UAT/E2E)

**Title:** PCA User-Specific Data Layer — Validation Report
**Dates:** <range> **Build/Versions:** app SHA, model\_version, schema\_version
**Flags timeline:** SHADOW → DRYRUN → ON → (FALLBACK drills with timestamps)
**Scope:** UAT A–G; E2E load/chaos/data-integrity

**Results Summary**

* UAT: XX/XX pass (100% required)
* E2E: p50/p95/p99, RAW success (100%), error rate, ask-rate
* Incidents: list, RCA, mitigation, current flag posture
* Data Integrity: raw checksums match; overlays-only mutations verified
* Policy: outbound messages = 0

**Go/No-Go:** GO / NO-GO
**Sign-offs:** PM • CTO/Eng Lead • QA Lead
**Rollback Readiness:** validated at <timestamp> (FALLBACK tested live)

---

## Production-Architecture Alignment & Zero-Risk Controls

* **Core immutability**: existing raw ledger remains append-only and untouched.
* **Overlay separation**: `TransactionEffective`, `UserCorrection`, `UserRule` already present; we use them without altering core tables.
* **Deterministic agent**: JSON-only CC; schema\_version/hash; idempotent `cc_id`.
* **Flag-gated rollout**: SHADOW → DRYRUN → ON (canary), instant safe **FALLBACK**.
* **Observability**: metrics + alerts bound to SLOs; chaos tested.
* **Performance**: current p95 is effectively 0ms (team data); even with precedence logic, target p95 < 900ms.
* **Risk items contained**: rule complexity handled via specificity ordering; precedence pre-cached for reports.

---

## Definition of Done (hard)

1. 100% UAT pass; 0 Sev-1/2 defects.
2. 100% RAW write success for money-event inputs (DRYRUN & ON).
3. Audit UI live (“Original vs Effective (your view)”).
4. Clarifier flow live; ask-rate 10–25%; correction-rate trending down.
5. p95 latency < 900ms; error rate < 0.5% during canary.
6. Rollback drill executed; `FALLBACK` restores legacy instantly.
7. Final signed test report; staged cohort expansion plan approved.

---

### Why this meets your team’s “Proceed with confidence ✅”

* **Architectural alignment:** matches your existing `models_pca.py` tables nearly 1:1.
* **Work remaining is focused:** precedence logic + UI surfaces + rule UX.
* **Safety proven:** flags, fallbacks, immutability, and idempotency already in place.
* **Business value immediate:** visible audit + per-user truth → trust and data quality, without touching the core ledger.

If you’d like, I can condense this into a one-page internal spec you can circulate for sign-off and sprint kickoff.
