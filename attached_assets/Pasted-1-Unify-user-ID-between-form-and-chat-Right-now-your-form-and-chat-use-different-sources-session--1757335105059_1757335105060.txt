1) Unify user ID between form and chat

Right now your form and chat use different sources (session vs header). Pick one. For PWAs, use localStorage and send it in the X-User-ID header.

<!-- templates/chat.html -->
<script>
function getOrCreateUserId() {
  const KEY = 'finbrain_uid';
  let id = localStorage.getItem(KEY);
  if (!id) {
    // UUIDv4-lite
    id = ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c =>
      (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
    );
    localStorage.setItem(KEY, id);
  }
  return id;
}
</script>

2) Make the chat fetch bulletproof

Catch network + JSON errors, show them in the UI, and include the header your backend expects.

<script>
async function sendChatMessage() {
  const input = document.querySelector('#chat-input');
  const btn = document.querySelector('#chat-send');
  const out = document.querySelector('#chat-output');

  const text = (input.value || '').trim();
  if (!text) return;

  const uid = getOrCreateUserId();
  btn.disabled = true;

  // Optimistic echo
  out.insertAdjacentHTML('beforeend', `<div class="msg you">${escapeHtml(text)}</div>`);

  try {
    const res = await fetch('/ai-chat', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-User-ID': uid
      },
      body: JSON.stringify({ message: text })
    });

    if (!res.ok) {
      const body = await res.text();
      throw new Error(`HTTP ${res.status}: ${body.slice(0, 500)}`);
    }

    let data;
    try {
      data = await res.json();
    } catch (e) {
      const raw = await res.text();
      throw new Error(`JSON parse failed. Raw: ${raw.slice(0, 500)}`);
    }

    const reply = data?.reply ?? data?.message ?? '[empty reply]';
    out.insertAdjacentHTML('beforeend', `<div class="msg bot">${escapeHtml(reply)}</div>`);
  } catch (err) {
    console.error('Chat error:', err);
    out.insertAdjacentHTML('beforeend',
      `<div class="msg error">Chat failed: ${escapeHtml(String(err.message || err))}</div>`);
  } finally {
    btn.disabled = false;
    input.value = '';
    out.scrollTop = out.scrollHeight;
  }
}

function escapeHtml(s){ return s.replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }

document.addEventListener('DOMContentLoaded', () => {
  document.querySelector('#chat-send').addEventListener('click', sendChatMessage);
  document.querySelector('#chat-input').addEventListener('keydown', e => {
    if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendChatMessage(); }
  });
});
</script>


Minimal HTML skeleton (keep your styles):

<div id="chat-output" class="chat"></div>
<div class="composer">
  <textarea id="chat-input" rows="1" placeholder="Type a message…"></textarea>
  <button id="chat-send">Send</button>
</div>

3) Harden the Flask endpoint

Accept JSON safely, read X-User-ID, and always return JSON your JS expects. If you use CSRF, exempt this endpoint.

# pwa_ui.py
from flask import Blueprint, request, jsonify, current_app
pwa_ui = Blueprint('pwa_ui', __name__)

def _json():
    try:
        return request.get_json(force=False, silent=True) or {}
    except Exception:
        return {}

@pwa_ui.route('/ai-chat', methods=['POST'])
# If using Flask-SeaSurf or WTForms CSRF, make sure to exempt this route.
# @csrf.exempt
def ai_chat():
    user_id = request.headers.get('X-User-ID') or request.cookies.get('user_id') or 'anon'
    payload = _json()
    message = (payload.get('message') or '').strip()

    if not message:
        return jsonify(error='Empty message'), 400

    try:
        # Your production router here:
        # reply = chat_router.respond(user_id=user_id, text=message)

        # Fallback-safe example:
        reply = handle_with_fallback_ai(user_id=user_id, text=message)

        return jsonify(reply=reply, user_id=user_id)
    except Exception as e:
        current_app.logger.exception('ai-chat failed')
        return jsonify(error='internal_error', detail=str(e)[:300]), 500

def handle_with_fallback_ai(user_id: str, text: str) -> str:
    # Replace with your real logic; ensure it never returns None
    # and never raises for common cases.
    return f"I heard: {text}"

4) Add backend logging that mirrors what the frontend needs

So you can line up Network tab with server logs.

@pwa_ui.before_app_request
def _dbg_req():
    if request.path == '/ai-chat' and request.method == 'POST':
        current_app.logger.info('ai-chat start uid=%s ctype=%s', 
                                request.headers.get('X-User-ID'),
                                request.headers.get('Content-Type'))

5) Quick endpoint self-test (no browser needed)

From your shell, verify headers, payload, and response shape.

curl -i -X POST http://localhost:5000/ai-chat \
  -H 'Content-Type: application/json' \
  -H 'X-User-ID: test-uid' \
  -d '{"message":"test from curl"}'


You should see 200 and {"reply": "...", "user_id":"test-uid"}.

6) Common gotchas to eliminate

CSRF blocking fetch: if you use CSRF, either include the token in the header or exempt this JSON endpoint.

Wrong content type: your fetch must send Content-Type: application/json, and your Flask must use request.get_json(...).

Mixed origins: if your PWA runs on a different origin/port, either proxy it or enable CORS explicitly for /ai-chat while you test.

Blueprint not registered: ensure app.register_blueprint(pwa_ui) is executed (with proper url_prefix).

Silent parse failure: without silent=True, Flask can 400 before your code runs. The helper above avoids that and you validate message yourself.

7) If you still don’t see bot replies

Open DevTools → Network → click your /ai-chat request.
Check:

Status code. Anything other than 200? Read “Response” tab for error JSON we now return.

Request headers include X-User-ID.

Request payload has { "message": "..." }.

Response JSON has reply. If not, the backend threw—your logs will now show the stack.

8) Optional: accept both JSON and form posts

If your form ever posts application/x-www-form-urlencoded, you can support both:

payload = _json()
if not payload:
    payload = request.form.to_dict()
message = (payload.get('message') or '').strip()