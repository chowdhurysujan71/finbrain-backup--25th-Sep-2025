# app.py
# FinBrain Coach – Messenger-ready minimal server with:
# - Conversational onboarding & thin-context UX
# - 4/60s per-user AI limiter + graceful fallback
# - Signature/HTTPS toggles for safe testing
# - Short-burst replies + quick replies
# - Simple in-memory DB (swap with your real DB)

import os, time, hmac, hashlib, json
from collections import deque, defaultdict
from flask import Flask, request, jsonify
import requests

# ========= Config (env) =========
PAGE_TOKEN = os.getenv("FB_PAGE_TOKEN", "TEST_PAGE_TOKEN")
APP_SECRET = os.getenv("FB_APP_SECRET", "TEST_APP_SECRET").encode()
VERIFY_FB_SIGNATURE = os.getenv("VERIFY_FB_SIGNATURE", "true").lower() == "true"
ENFORCE_HTTPS = os.getenv("ENFORCE_HTTPS", "true").lower() == "true"
DRY_RUN = os.getenv("DRY_RUN", "true").lower() == "true"  # if true, don't call FB Send API

MSG_MAX_CHARS = int(os.getenv("MSG_MAX_CHARS", "280"))
AI_RL_USER_LIMIT = 4
AI_RL_WINDOW_SEC = 60

app = Flask(__name__)

# ========= Minimal “DB” (replace with your DB) =========
class MemDB:
    def __init__(self):
        self.users = {}          # psid -> dict
        self.expenses = defaultdict(list)  # psid -> [(cat, amt, ts)]
        self.caps = defaultdict(dict)      # psid -> {cat: limit}

    # getters/setters
    def set_user(self, psid, data):
        self.users.setdefault(psid, {}).update(data)

    def get_user(self, psid):
        return self.users.get(psid, {})

    def add_expense(self, psid, category, amount):
        self.expenses[psid].append((category, float(amount), time.time()))

    def get_spend_by_category(self, psid, days=30, days_end=0):
        now = time.time()
        start = now - (days + days_end) * 86400
        end = now - days_end * 86400
        sums = defaultdict(float)
        for cat, amt, ts in self.expenses[psid]:
            if start <= ts <= end:
                sums[cat] += amt
        return list(sums.items())

    def get_goals(self, psid):
        return self.users.get(psid, {}).get("goals", [])

    def set_cap(self, psid, category, limit_bdt):
        self.caps[psid][category] = float(limit_bdt)

db = MemDB()

# ========= RL-2 limiter (per-user + simple global) =========
class SlidingWindowLimiter:
    def __init__(self, limit, window_sec):
        self.limit = limit
        self.window = window_sec
        self.store = {}  # key -> deque[timestamps]

    def allow(self, key, now=None):
        now = now or time.time()
        q = self.store.setdefault(key, deque())
        while q and (now - q[0]) > self.window:
            q.popleft()
        if len(q) < self.limit:
            q.append(now)
            return True, 0
        retry_in = int(max(1, self.window - (now - q[0])))
        return False, retry_in

RL2_USER = SlidingWindowLimiter(AI_RL_USER_LIMIT, AI_RL_WINDOW_SEC)

def can_use_ai(psid):
    return RL2_USER.allow(f"user:{psid}")

# ========= Helpers: signature, send API, quick replies =========
def verify_fb_signature(req):
    if not VERIFY_FB_SIGNATURE:
        return
    sig = req.headers.get("X-Hub-Signature-256")
    if not sig or not sig.startswith("sha256="):
        return ("Missing/invalid signature", 403)
    provided = sig.split("=", 1)[1]
    computed = hmac.new(APP_SECRET, req.data, hashlib.sha256).hexdigest()
    if not hmac.compare_digest(provided, computed):
        return ("Bad signature", 403)

def is_https(req):
    return req.is_secure or req.headers.get("X-Forwarded-Proto", "").lower() == "https"

def appsecret_proof(token):
    return hmac.new(APP_SECRET, msg=token.encode(), digestmod=hashlib.sha256).hexdigest()

def send_message(psid, text):
    # enforce short-burst cap at send layer
    if len(text) > MSG_MAX_CHARS:
        text = f"{text[:MSG_MAX_CHARS-18].rstrip()}… Want details?"
    if DRY_RUN:
        print(f"[DRY_SEND] -> {psid}: {text}")
        return
    params = {"access_token": PAGE_TOKEN, "appsecret_proof": appsecret_proof(PAGE_TOKEN)}
    payload = {"recipient": {"id": psid}, "message": {"text": text}}
    r = requests.post("https://graph.facebook.com/v21.0/me/messages", params=params, json=payload, timeout=5)
    r.raise_for_status()

def send_quick_replies(psid, qr):
    if DRY_RUN:
        print(f"[DRY_QR] -> {psid}: {qr}")
        return
    params = {"access_token": PAGE_TOKEN, "appsecret_proof": appsecret_proof(PAGE_TOKEN)}
    payload = {
        "recipient": {"id": psid},
        "message": {"text": "Pick one:", "quick_replies": [
            {"content_type":"text","title":i["title"],"payload":i["payload"]} for i in qr
        ]}
    }
    r = requests.post("https://graph.facebook.com/v21.0/me/messages", params=params, json=payload, timeout=5)
    r.raise_for_status()

# ========= UX text helpers =========
def fallback_blurb(retry_in):
    return ("Taking a quick breather to stay fast & free. "
            f"I’ll do the smart analysis in ~{retry_in}s. Meanwhile, want a quick action?")

def format_coach_reply(summary, action, question):
    msg = f"{summary}\n{action}\n{question}"
    return msg if len(msg) <= MSG_MAX_CHARS else f"{msg[:MSG_MAX_CHARS-18].rstrip()}… Want details?"

# ========= NLP utils =========
import re
def parse_expense(text):
    m = re.match(r"\s*([A-Za-z ]+)\s+(\d+(?:\.\d{1,2})?)\s*$", text)
    return (m.group(1).strip().title(), float(m.group(2))) if m else (None, None)

# ========= Context builder =========
def build_context(psid):
    income_30d = int(db.get_user(psid).get("income_30d", 0))
    cur = dict(db.get_spend_by_category(psid, days=30))
    prev = dict(db.get_spend_by_category(psid, days=60, days_end=31))
    def d(c):
        p = prev.get(c, 0.0)
        return int(round(100 * ((cur[c]-p)/(p if p > 0 else 1e-9))))
    deltas = [(c, int(cur[c]), d(c)) for c in cur]
    top = sorted(deltas, key=lambda x: x[1], reverse=True)[:5]
    return {
        "income_30d": income_30d,
        "total_spend_30d": int(sum(cur.values())),
        "top_cats": [{"category": c, "amount": a, "delta_pct": dp} for c,a,dp in top],
        "goals": db.get_goals(psid),
    }

# ========= “AI” adapter (stub: plug your LLM here) =========
def ai_reply(psid, user_text):
    ctx = build_context(psid)
    thin = (ctx["total_spend_30d"] == 0) or (len(ctx["top_cats"]) < 2)
    if thin:
        return {
            "summary": "I don’t see enough recent spend to personalize this.",
            "action": "Log your 3 biggest expenses today so I can analyze.",
            "question": "Want to log them now or import last month’s data?"
        }
    # With data → craft short numeric insight
    top = ctx["top_cats"][0]
    cat, amt, dp = top["category"], top["amount"], top["delta_pct"]
    shift = max(500, int(0.15 * amt))
    return {
        "summary": f"{cat} is ৳{amt:,} in 30d ({dp:+d}%).",
        "action": f"Shift ৳{shift:,} to savings or leisure; I can set a cap.",
        "question": f"Apply a cap for {cat} now or see the breakdown?"
    }

# ========= Core handler =========
_last_msg = {}  # prevent repeated identical text loop

def handle_message(psid, text):
    # Non-AI fast path: expense logging like "Groceries 500"
    cat, amt = parse_expense(text)
    if cat and amt:
        db.add_expense(psid, cat, amt)
        send_message(psid, f"Logged {cat} ৳{int(amt):,}. Need a 7-day snapshot?")
        return send_quick_replies(psid, [
            {"title":"Snapshot","payload":"SHOW_SNAPSHOT"},
            {"title":"Set cap","payload":"SET_GOAL"},
            {"title":"Done","payload":"DONE"},
        ])

    allowed, retry_in = can_use_ai(psid)
    if not allowed:
        txt = fallback_blurb(retry_in)
        if _last_msg.get(psid) != txt:
            send_message(psid, txt)
            _last_msg[psid] = txt
        return send_quick_replies(psid, [
            {"title":"Log Expense","payload":"LOG_EXPENSE"},
            {"title":"Weekly Review","payload":"WEEKLY_REVIEW"},
            {"title":"Set Goal","payload":"SET_GOAL"},
        ])

    out = ai_reply(psid, text)
    msg = format_coach_reply(out["summary"], out["action"], out["question"])
    if _last_msg.get(psid) != msg:
        send_message(psid, msg)
        _last_msg[psid] = msg
    return send_quick_replies(psid, [
        {"title":"Apply cap","payload":"APPLY_CAP"},
        {"title":"Breakdown","payload":"SHOW_BREAKDOWN"},
        {"title":"Not now","payload":"IGNORE"},
    ])

def handle_payload(psid, payload):
    if payload == "LOG_EXPENSE":
        return send_message(psid, "Type like: Groceries 650")
    if payload == "SHOW_SNAPSHOT":
        rows = db.get_spend_by_category(psid, days=7)
        if not rows:
            return send_message(psid, "No spend in last 7 days.")
        top = ", ".join([f"{c} ৳{int(a):,}" for c,a in sorted(rows, key=lambda x: x[1], reverse=True)[:3]])
        return send_message(psid, f"7-day snapshot: {top}.")
    if payload == "APPLY_CAP":
        # naive: cap top category
        cur = dict(db.get_spend_by_category(psid, days=30))
        if not cur: return send_message(psid, "No spend to cap yet.")
        cat = sorted(cur.items(), key=lambda x: x[1], reverse=True)[0][0]
        new_cap = int(cur[cat] * 0.85)
        db.set_cap(psid, cat, new_cap)
        return send_message(psid, f"Done. {cat} cap set to ৳{new_cap:,} for next period.")
    if payload == "SET_GOAL":
        return send_message(psid, "Which category should we cap? Try: Dining 6500")
    # add more as needed
    return send_message(psid, "Okay.")

# ========= Flask webhook =========
@app.route("/webhook", methods=["GET"])
def verify():
    # Standard FB webhook verification
    mode = request.args.get("hub.mode")
    token = request.args.get("hub.verify_token")
    challenge = request.args.get("hub.challenge")
    if mode == "subscribe" and token == os.getenv("FB_VERIFY_TOKEN", "verify_me"):
        return challenge, 200
    return "Forbidden", 403

@app.route("/webhook", methods=["POST"])
def webhook():
    if ENFORCE_HTTPS and not is_https(request):
        return ("HTTPS required", 400)
    sig_err = verify_fb_signature(request)
    if sig_err: return sig_err

    data = request.get_json(force=True, silent=True) or {}
    for entry in data.get("entry", []):
        for event in entry.get("messaging", []):
            psid = event.get("sender", {}).get("id")
            if not psid: continue
            if "message" in event and "text" in event["message"]:
                handle_message(psid, event["message"]["text"].strip())
            elif "postback" in event:
                payload = event["postback"].get("payload", "")
                handle_payload(psid, payload)
    return "EVENT_RECEIVED", 200

# ========= Local run =========
if __name__ == "__main__":
    print("FinBrain Coach starting…")
    print({"verify_sig": VERIFY_FB_SIGNATURE, "enforce_https": ENFORCE_HTTPS,
           "rl_user_limit": AI_RL_USER_LIMIT, "msg_cap": MSG_MAX_CHARS})
    app.run(host="0.0.0.0", port=int(os.getenv("PORT", 3000)))
