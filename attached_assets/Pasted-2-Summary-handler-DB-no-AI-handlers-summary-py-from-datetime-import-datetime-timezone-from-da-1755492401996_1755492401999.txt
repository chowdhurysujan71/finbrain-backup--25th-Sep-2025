2) Summary handler (DB, no AI)
# handlers/summary.py
from datetime import datetime, timezone
from dateutil.relativedelta import relativedelta
from utils.db import db

def month_bounds(now=None, tz=timezone.utc):
    now = now or datetime.now(tz)
    start = now.replace(day=1, hour=0, minute=0, second=0, microsecond=0)
    if start.month == 12:
        end = start.replace(year=start.year+1, month=1)
    else:
        end = start.replace(month=start.month+1)
    return start, end

def handle_summary(user_id: str) -> dict:
    start, end = month_bounds()
    rows = db.fetch_all(
        """
        SELECT category, SUM(amount) AS total, COUNT(*) AS n
        FROM expenses
        WHERE user_id=%s AND created_at >= %s AND created_at < %s
        GROUP BY category
        ORDER BY total DESC
        """,
        (user_id, start, end)
    )
    total = sum(r["total"] for r in rows) if rows else 0
    top = rows[0]["category"] if rows else "‚Äî"
    top_amt = rows[0]["total"] if rows else 0
    entries = sum(r["n"] for r in rows) if rows else 0

    msg = (
        f"üìä This month so far: {total:.0f} BDT across {entries} entries.\n"
        f"Top category: {top} ({top_amt:.0f}).\n"
        f"Tip: type 'insight' for a quick read on what to optimize."
    )
    return {"text": msg}


Ensure your dispatcher sends this message when intent == "SUMMARY".

3) Deterministic ‚Äúinsight‚Äù (no AI required)
# handlers/insight.py
from utils.db import db
from .summary import month_bounds

def handle_insight(user_id: str) -> dict:
    start, end = month_bounds()
    rows = db.fetch_all(
        "SELECT category, SUM(amount) AS total FROM expenses "
        "WHERE user_id=%s AND created_at >= %s AND created_at < %s "
        "GROUP BY category ORDER BY total DESC",
        (user_id, start, end)
    )
    total = sum(r["total"] for r in rows) or 0
    if not total:
        return {"text": "No spend logged yet this month. Log a few expenses first."}

    lines = []
    for r in rows[:4]:
        pct = (r["total"]/total)*100
        lines.append(f"‚Ä¢ {r['category']}: {r['total']:.0f} ({pct:.0f}%)")

    # simple rules
    alerts = []
    for r in rows:
        pct = (r["total"]/total)*100
        if r["category"].lower() in {"groceries","food"} and pct > 30:
            alerts.append("Groceries >30% ‚Äî plan a 10% cut with a weekly list.")
        if r["category"].lower() in {"ride","transport","uber"} and pct > 20:
            alerts.append("Transport >20% ‚Äî try batching trips or off-peak times.")

    msg = "üß† Quick insights:\n" + "\n".join(lines)
    if alerts:
        msg += "\n\n‚ö†Ô∏è Suggestions:\n" + "\n".join(f"‚Ä¢ {a}" for a in alerts)
    else:
        msg += "\n\n‚úÖ Nice balance. Keep it up!"
    return {"text": msg}

4) Parser for multi-amount messages (your ‚ÄúUber 100 + shoe 500‚Äù case)
# utils/parser.py
import re

AMOUNT = r'(\d+(?:\.\d{1,2})?)'
CURRENCY = r'(?:\s*(?:bdt|tk|usd))?'
ITEM = r'(?:on|for)?\s*([a-z ]{0,30})'

def extract_expenses(text):
    t = text.lower()
    # find all numbers; try to attach a nearby noun as category hint
    nums = re.findall(AMOUNT + CURRENCY, t)
    cats = []
    if "grocery" in t or "grocer" in t: cats.append("Groceries")
    if "uber" in t or "ride" in t or "transport" in t: cats.append("Transport")
    if "shoe" in t: cats.append("Shopping")
    # fallback category per number when hints run out
    out = []
    for i, n in enumerate(nums):
        cat = cats[i] if i < len(cats) else "Uncategorized"
        out.append({"amount": float(n[0]), "category": cat})
    return out


Use this in the LOG handler to insert both amounts instead of only the first.

5) Dispatcher (make the fallback last)
# utils/dispatcher.py
from utils.intent_router import detect_intent
from handlers.summary import handle_summary
from handlers.insight import handle_insight
from handlers.logger import handle_log  # your existing logger

def handle_event(user_id, text):
    intent = detect_intent(text)
    if intent == "SUMMARY":
        return handle_summary(user_id)
    if intent == "INSIGHT":
        return handle_insight(user_id)
    if intent == "LOG_EXPENSE":
        return handle_log(user_id, text)
    return {"text": "I didn‚Äôt catch that. Try: ‚Äòsummary‚Äô, ‚Äòinsight‚Äô, or ‚ÄòI spent 500 on groceries‚Äô."}

6) Don‚Äôt rate-limit non-AI paths

If you have a per-minute AI cap, apply it only when you call the AI. The SUMMARY/INSIGHT above are deterministic and should bypass the AI limiter.

if intent in {"SUMMARY","INSIGHT"}:
    return handler(...)  # no AI limiter
if intent_uses_ai(intent):
    check_ai_limiter_or_fallback()
