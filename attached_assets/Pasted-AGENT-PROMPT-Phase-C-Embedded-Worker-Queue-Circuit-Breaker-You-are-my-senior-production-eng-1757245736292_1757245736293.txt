AGENT PROMPT — Phase C (Embedded Worker Queue + Circuit Breaker)

You are my senior production engineer. Implement Phase C: Resilience with a Redis-backed job queue and circuit breaker. Use embedded background workers (utils/background_processor.py) instead of a separate repl. Make MINIMAL, NON-BREAKING edits.

Goals
1) Job Queue
- Redis (Upstash) used for enqueue/dequeue.
- New endpoint POST /jobs:
  • Body: {"type": "analysis", "payload": {...}, "idempotency_key": "..."}
  • Enqueue job with generated job_id.
  • Respond immediately: {"job_id": "...", "status":"queued"}
- Endpoint GET /jobs/{job_id}/status:
  • Returns {"job_id","status":"queued|running|succeeded|failed","attempts":N,"result_path":optional,"error":optional}
- Endpoint POST /jobs/{job_id}/cancel (best effort).
- Ensure idempotency: repeat requests with same idempotency_key → same job_id.

2) Worker Processing
- Extend utils/background_processor.py:
  • Pull jobs from Redis list/stream.
  • Track attempts, timestamps.
  • Store results in Supabase (reuse storage_supabase.py).
  • On success → mark job "succeeded" with result_path.
  • On permanent failure → mark job "failed" + send to DLQ (Redis list "jobs:dlq").
- Implement retries: 3 attempts with exponential backoff (1s, 5s, 30s).
- Expire completed job metadata after 24h (Redis TTL).

3) Circuit Breaker
- For AI provider errors (HTTP 429, 500, timeout):
  • Track failure count per minute.
  • If >5 failures in a rolling 60s → breaker "open".
  • While open: new jobs return 429 {"error":"temporarily unavailable"}.
  • After 30s, half-open probe → if success, close breaker.

4) Observability
- Log JSON lines for enqueue/dequeue/complete with request_id, job_id, user_id, attempts, latency_ms.
- Add Sentry breadcrumb per job step, event on final failure.

5) Security & Validation
- Require X-User-ID on all /jobs endpoints.
- Limit per-user enqueue rate (e.g., 60 jobs/hour); return 429 if exceeded.
- Validate payload size ≤1MB.

6) Docs
- /docs/queue-spec.md: architecture, endpoints, retry logic, DLQ, circuit breaker.
- /docs/circuit-breaker.md: failure thresholds, states (closed/open/half-open), runbook.

7) Tests
- tests/test_jobs_queue.py:
  • Enqueue job → check queued.
  • Force success → status=succeeded.
  • Force failure → 3 retries → DLQ.
  • Idempotency → same job_id reused.
  • Rate limit → 429 when exceeded.
  • Circuit breaker transitions closed→open→half-open→closed.

8) Commit
- Commit message: feat(queue): Redis-backed jobs with retries, DLQ, circuit breaker, status API, docs, tests.

Constraints
- Do NOT remove utils/background_processor.py — extend it.
- Do NOT break existing endpoints.
- Keep Redis usage minimal: lists or streams + hashes for metadata.
- Ensure /readyz includes Redis connectivity check if not already present.
