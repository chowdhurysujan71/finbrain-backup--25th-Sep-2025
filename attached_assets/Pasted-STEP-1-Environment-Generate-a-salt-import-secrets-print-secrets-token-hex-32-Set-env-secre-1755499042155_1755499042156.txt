STEP 1 — Environment

Generate a salt:

import secrets; print(secrets.token_hex(32))


Set env/secrets:

ID_SALT=<64 hex>
AI_ENABLED=true
AI_PROVIDER=gemini
GEMINI_API_KEY=<real key>


Remove OPENAI_* secrets if present.
Commit: chore(env): set ID_SALT and Gemini provider

STEP 2 — Canonical Identity

Create utils/identity.py:

import hashlib, os
_ID_SALT = os.getenv("ID_SALT", "CHANGE_ME")
def psid_hash(raw_psid: str) -> str:
    return hashlib.sha256((raw_psid + _ID_SALT).encode()).hexdigest()


Patch webhook:

from utils.identity import psid_hash
@app.route("/webhook", methods=["POST"])
def webhook():
    data = request.get_json(force=True, silent=True) or {}
    try:
        raw_psid = data["entry"][0]["messaging"][0]["sender"]["id"]
    except Exception as e:
        app.logger.warning(f"Webhook missing PSID: {e}")
        return "EVENT_RECEIVED", 200
    g.user_hash = psid_hash(raw_psid)
    return handle_message(data, g.user_hash)


Add /ops/hash route:

@app.get("/ops/hash")
def ops_hash():
    psid = request.args.get("psid", "")
    from utils.identity import psid_hash
    return {"psid": psid, "psid_hash": psid_hash(psid)}, 200


Commit: feat(identity): canonical PSID hash + /ops/hash

STEP 3 — DB Constraint

Add unique index:
SQLite

CREATE UNIQUE INDEX IF NOT EXISTS idx_users_psid_hash_unique ON users(psid_hash);


Postgres

DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname='idx_users_psid_hash_unique') THEN
    CREATE UNIQUE INDEX idx_users_psid_hash_unique ON users(psid_hash);
  END IF;
END$$;


Commit: db(migration): unique index on users.psid_hash

STEP 4 — Merge/Archive Duplicates

Create scripts/migrate_identity.py (full version from me).

Run dry run:

DATABASE_URL=$DATABASE_URL ID_SALT=$ID_SALT python scripts/migrate_identity.py


→ check merge_mapping.json.

If looks good, apply:

DATABASE_URL=$DATABASE_URL ID_SALT=$ID_SALT python scripts/migrate_identity.py --apply


Commit: feat(migration): merge duplicates + archive test users

STEP 5 — Single Summary Service

Create services/summary.py with computed_summary(psid_hash, 7).

Make Admin “Explore” and Messenger both call this function.
Commit: feat(summary): unified computed_summary service

STEP 6 — AI Insights Wrapper

Create ai/insights.py with:

deterministic baseline (total, top category)

Gemini call if AI_ENABLED

fallback if error → return baseline + “Non-AI tip”

Replace all “AI Insights” calls with generate_insight_text(summary).
Commit: feat(ai): resilient insight wrapper with fallback

STEP 7 — Smoke Test

Create scripts/smoke.py:

import requests, os
BASE = os.getenv("BASE_URL","http://localhost:5000")
psid = os.getenv("TEST_PSID","123456")
print("hash:", requests.get(f"{BASE}/ops/hash", params={"psid":psid}).json())


Run with a known PSID.
→ Confirm hash equals Admin’s psid_hash.
Commit: test: smoke test for identity