FinBrain Guardrails (Safe, Modular, Reversible)

You are editing the FinBrain repo with these key files:
utils/production_router.py, utils/intent_router.py, utils/ai_adapter_v2.py, utils/dispatcher.py, handlers/*, limiter.py.

HARD CONSTRAINTS

Do not rename or move files.

Do not change endpoints, DB schema, or handler/dispatcher interfaces.

All changes must be additive and feature-flagged.

Preserve the core flow: Limiter → RL-2 (if limited) → AI (if enabled) → Rules (fallback).

Owner bypass must apply to all guardrails.

GOALS

Add UX copy constants (one place, friendly tone).

Add Messaging Guardrail Prompt (prepend in AI adapter; UX polish, zero risk).

Add Guardrail middleware in ProductionRouter (burst limiter + daily cap + PII + anti-repeat), all flag-gated and owner-bypassed.

Provide unit tests, UAT steps, and an End-of-Run report.

Owner (bypass):

Raw PSID: 30522114904098519

Hashed PSID: a20425ef…16ff

Environment flags (read at runtime; default safe OFF):

FEATURE_BURST_LIMIT=true|false
FEATURE_DAILY_CAP=true|false
FEATURE_PII_FILTER=true|false
FEATURE_ANTI_REPEAT=true|false
OWNER_PSID=30522114904098519
OWNER_PSID_HASH=a20425ef…16ff
DAILY_CAP_LIMIT=30
BURST_LIMIT_MAX=5
BURST_LIMIT_WINDOW_SECONDS=10


If Redis is available, use it; otherwise fall back to an in-process TTL dict (loses data on restart, which is acceptable for MVP).

PART 1 — New UX copy constants
Create: utils/ux_copy.py
# utils/ux_copy.py
SLOW_DOWN = "⚠️ You’re sending messages very fast—please slow down."
DAILY_LIMIT = "⏳ You’ve reached today’s limit of 30 messages. Please come back tomorrow."
REPEAT_HINT = "Got that—anything new you’d like me to do now: log, summary, or insight?"
PII_WARNING = "🔒 For your security, please don’t share sensitive information here."
BUSY = "⏳ FinBrain is a bit busy right now. Please try again in a few minutes."
FALLBACK = ("🧭 I can help you log expenses, show summaries, or share insights. "
            "Try: ‘coffee 120’ or ‘summary this week’. For details visit www.finbrain.app")

PART 2 — Messaging guardrail prompt (prepend; AI polish)
Edit: utils/ai_adapter_v2.py

Add this constant and prepend it when composing the system prompt.

# utils/ai_adapter_v2.py
MESSAGING_GUARDRAIL_PROMPT = (
    "You are FinBrain, a friendly financial companion in chat. "
    "Be natural and supportive, not robotic. One reply per message; keep it short (2–4 sentences, ≤280 chars). "
    "Use 0–2 emojis max; pick ones that fit (🧾 logging, 📊 reports, 💡 insights, 🔒 security, 🧭 fallback). "
    "Avoid repeating the same phrase within 2 minutes; vary phrasing. "
    "Ask one clarifying question if needed; end with at most one clear next step. "
    "Never ask for or echo card numbers, passwords, or personal identifiers. "
)

def _compose_system_prompt(self, base_prompt: str) -> str:
    # If a similar helper exists, extend that instead.
    return f"{MESSAGING_GUARDRAIL_PROMPT}\n\n{base_prompt}"


Ensure wherever you send the system prompt to the model, you call _compose_system_prompt(...).

PART 3 — Lightweight TTL store (Redis or in-proc)
Create: utils/ttl_store.py
# utils/ttl_store.py
import os, time, threading
from typing import Optional

class InProcTTL:
    def __init__(self):
        self._d = {}
        self._lock = threading.Lock()

    def _purge(self):
        now = time.time()
        to_del = [k for k, (_, exp) in self._d.items() if exp and exp < now]
        for k in to_del:
            self._d.pop(k, None)

    def incr(self, key: str, ttl_seconds: Optional[int] = None) -> int:
        with self._lock:
            self._purge()
            val, exp = self._d.get(key, (0, 0))
            val += 1
            if ttl_seconds:
                exp = time.time() + ttl_seconds
            self._d[key] = (val, exp)
            return val

    def get(self, key: str) -> Optional[int]:
        with self._lock:
            self._purge()
            v = self._d.get(key)
            return v[0] if v else None

    def setex(self, key: str, ttl_seconds: int, value: int = 1) -> None:
        with self._lock:
            self._purge()
            self._d[key] = (value, time.time() + ttl_seconds)

    def exists(self, key: str) -> bool:
        with self._lock:
            self._purge()
            return key in self._d

# Minimal facade that prefers Redis if configured
def get_store():
    REDIS_URL = os.getenv("REDIS_URL")
    if REDIS_URL:
        # Lazy import to avoid dependency if not present
        import redis  # type: ignore
        client = redis.Redis.from_url(REDIS_URL)
        class RedisTTL:
            def incr(self, key: str, ttl_seconds: Optional[int] = None) -> int:
                p = client.pipeline()
                p.incr(key)
                if ttl_seconds and (not client.ttl(key) or client.ttl(key) < 0):
                    p.expire(key, ttl_seconds)
                return p.execute()[0]
            def get(self, key: str):
                v = client.get(key)
                return int(v) if v else None
            def setex(self, key: str, ttl_seconds: int, value: int = 1):
                client.setex(key, ttl_seconds, value)
            def exists(self, key: str) -> bool:
                return bool(client.exists(key))
        return RedisTTL()
    return InProcTTL()

PART 4 — Guardrail middleware (burst, daily cap, PII, anti-repeat)
Edit: utils/production_router.py

Add imports at top:

import os, re, time, datetime
from utils.ttl_store import get_store
from utils.ux_copy import SLOW_DOWN, DAILY_LIMIT, REPEAT_HINT, PII_WARNING


Inside the router class __init__ (or module level), create the store once:

STORE = get_store()


Add a small helper near the top of the file:

def _is_owner(psid: str, psid_hash: str) -> bool:
    return psid == os.getenv("OWNER_PSID") or psid_hash == os.getenv("OWNER_PSID_HASH")

def _utc_seconds_until_midnight() -> int:
    now = datetime.datetime.utcnow()
    tomorrow = now + datetime.timedelta(days=1)
    midnight = datetime.datetime(tomorrow.year, tomorrow.month, tomorrow.day)
    return int((midnight - now).total_seconds())

_CARD_RE = re.compile(r"(?:\D|^)(\d{13,19})(?:\D|$)")
_PASS_RE = re.compile(r"\b(pass(word)?|pin|otp)\b", re.I)


Right after you parse user_text and have psid and psid_hash, before intent detection/AI/dispatcher, insert:

def _guardrail_gate(self, psid: str, psid_hash: str, text: str):
    # Bypass for owner
    if _is_owner(psid, psid_hash):
        return None  # no message, continue normal flow

    # Read flags
    burst_on = os.getenv("FEATURE_BURST_LIMIT", "false").lower() == "true"
    daily_on = os.getenv("FEATURE_DAILY_CAP", "false").lower() == "true"
    pii_on   = os.getenv("FEATURE_PII_FILTER", "false").lower() == "true"
    rep_on   = os.getenv("FEATURE_ANTI_REPEAT", "false").lower() == "true"

    # 1) Burst limiter (5 msgs / 10s default)
    if burst_on:
        window = int(os.getenv("BURST_LIMIT_WINDOW_SECONDS", "10"))
        maxn   = int(os.getenv("BURST_LIMIT_MAX", "5"))
        burst_key = f"burst:{psid}"
        cnt = STORE.incr(burst_key, ttl_seconds=window)
        if cnt > maxn:
            return SLOW_DOWN

    # 2) Daily cap (30/day default; TTL to UTC midnight)
    if daily_on:
        today = datetime.datetime.utcnow().strftime("%Y%m%d")
        daily_key = f"daily:{psid}:{today}"
        if not STORE.exists(daily_key):
            STORE.setex(daily_key, _utc_seconds_until_midnight(), 0)
        cnt = STORE.incr(daily_key)  # ttl preserved by Redis pipeline or in-proc wrapper
        limit = int(os.getenv("DAILY_CAP_LIMIT", "30"))
        if cnt > limit:
            return DAILY_LIMIT

    # 3) PII light filter (regex-first)
    if pii_on:
        if _CARD_RE.search(text) or _PASS_RE.search(text):
            return PII_WARNING

    # 4) Anti-repeat (exact text within 120s)
    if rep_on:
        rep_key = f"repeat:{psid}"
        last = STORE.get(rep_key)
        # naive hash via exact string length + first/last chars to avoid storing content
        h = f"{len(text)}:{text[:8]}:{text[-8:]}" if text else "0::"
        if str(last) == h:
            # refresh TTL and short-circuit
            STORE.setex(rep_key, 120, last if last else 0)
            return REPEAT_HINT
        STORE.setex(rep_key, 120, h)

    return None


Then call it in your main message handler (early in the request):

gate_msg = self._guardrail_gate(psid=user_psid, psid_hash=user_psid_hash, text=user_text)
if gate_msg:
    return gate_msg


Do not change anything else in the router order. Leave rate-limiter, RL-2, AI flags, dispatcher, and handlers untouched.

PART 5 — Tests (additive, simple)
Create: tests/test_guardrails.py
import os, time, datetime
from utils.ttl_store import get_store
from utils.ux_copy import SLOW_DOWN, DAILY_LIMIT, REPEAT_HINT, PII_WARNING

def test_ttl_store_basic():
    store = get_store()
    k = "unit:test"
    c1 = store.incr(k, ttl_seconds=1)
    assert c1 == 1
    time.sleep(1.1)
    assert store.get(k) in (None, 0)

def test_copy_constants_present():
    assert "slow" in SLOW_DOWN.lower()
    assert "limit" in DAILY_LIMIT.lower()
    assert "security" in PII_WARNING.lower()

def test_repeat_hint_copy():
    assert "anything new" in REPEAT_HINT.lower()


(Router integration tests depend on your framework; above verifies the building blocks.)

PART 6 — UAT (manual, production-like)

Setup

Set ENV flags:

FEATURE_BURST_LIMIT=true

FEATURE_DAILY_CAP=true

FEATURE_PII_FILTER=true

FEATURE_ANTI_REPEAT=true

OWNER_PSID=30522114904098519

OWNER_PSID_HASH=a20425ef…16ff

Keep your normal AI flags on. Deploy to your Reserved VM.

Steps

Burst limiter

From a non-owner test PSID, send 6 messages in 10s → expect exactly one reply: SLOW_DOWN. Next message after 10s should process normally.

Daily cap

From a fresh non-owner PSID, send 31 messages in the same UTC day → the 31st gets DAILY_LIMIT. Additional messages before midnight UTC should not produce additional replies (or repeat at most once per hour if you choose).

Reset at midnight (UTC)

After UTC midnight (or simulate by changing system date in a staging env), send again → processed normally (counter reset).

PII safety

Send a 16-digit numeric sequence or “my password is 1234” → receive exactly one PII_WARNING; original content must not be echoed.

Anti-repeat (120s)

Send the exact same text twice within 2 minutes → second gets REPEAT_HINT; a different text processes normally.

Owner bypass

Using your PSID/hash → you should never see SLOW_DOWN or DAILY_LIMIT; everything flows normally.

Normal UX intact

Try coffee 120, today summary, insight → replies are short, single bubble, ≤2 emojis, one CTA (prompt prepend working).

Pass Criteria

Guardrail messages appear only when triggered.

No crashes; expense logging and summaries continue to work.

Feature flags allow toggling each guardrail without redeploy.

Owner bypass always respected.

PART 7 — End-of-Run Report (fill after UAT)

Deployment: <commit/build id>
Env: Replit Reserved VM (0.5 vCPU / 2 GiB)
Date (UTC+6): <YYYY-MM-DD>
Tester: <name>

Summary

✅ Messaging guardrail prompt live (concise, friendly, non-robotic).

✅ Burst limiter (5/10s) working, flag-gated.

✅ Daily cap (30/day) with UTC midnight reset, flag-gated.

✅ PII light filter (regex) active.

✅ Anti-repeat (exact text, 120s TTL) active.

✅ Owner bypass (PSID 30522114904098519 / hash a20425ef…16ff) verified.

✅ No regressions in logging/summary/insight.

Evidence (screenshots/logs)

Burst hit example

Daily cap message

PII warning

Repeat hint

Normal summary reply

Issues

<None / list defects with severity, repro, expected vs actual>

Go/No-Go

GO / NO-GO (select)

Sign-off: <name>

Why this won’t break your system

Router change is a self-contained middleware before your existing flow, fully flag-gated and owner-bypassed.

No DB schema changes; TTL store prefers Redis but safely falls back to in-proc.

AI prompt prepend is read-only; easy to revert.

UX copy is centralized for consistency.