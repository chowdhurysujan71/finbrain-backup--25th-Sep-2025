Stabilize FinBrain (always-on AI, no flags)

Goal: Make AI routing, tone, and corrections always on (no feature flags/allowlists) while fixing repeated regressions: config drift, legacy short-circuit, idempotency by mid, and single-hit logging. This is pre-launch; when the Messenger “live” lever flips, bot opens for everyone automatically.

Hard constraints

Do not change external routes, payloads, auth, or schema fields used by legacy code.

Backwards-compatible DB changes only (additive or safe index changes).

Keep idempotency: one DB row per (psid_hash, mid) (or derived mid segment for multi-expense).

Provide tests and a one-command verification script.

0) Remove flags & allowlists (centralize config)

Files: utils/feature_flags.py, .env, any flag readers in router/handlers

Delete/ignore these envs and code branches:

SMART_NLP_ROUTING(_DEFAULT), SMART_NLP_TONE_FOR_STD(_DEFAULT), SMART_CORRECTIONS(_DEFAULT)

FEATURE_ALLOWLIST_*

Replace feature_enabled(psid_hash, "…") calls with constant True (single source):

def feature_enabled(*_args, **_kwargs): return True

Keep the function for easy rollback, but it always returns True.

Add a single “config version” env for cache busting:

FEATURE_FLAGS_VERSION=always_on_v1

Ensure router logs this each request (debug banner).

1) Router precedence (AI first, no legacy short-circuit)

Files: finbrain/router.py

Remove/disable the hard short-circuit line:

"[ROUTER] Money detected - forcing LOG intent" and details":"legacy_money_detected"

New order:

Detect CORRECTION (keywords + number fallback) → intent="CORRECTION"

Else, run AI routing (NLP classification LOG/QUERY/SUMMARY)

Else, fall back to legacy only if AI yields none

Always emit a banner line:

[ROUTER] mode=AI features=[NLP_ROUTING,TONE,CORRECTIONS] config_version=always_on_v1 psid=...

2) Multi-expense logging (iterate all money hits)

Files: parsers/expense.py, handlers/expense.py

Implement extract_all_expenses(text) -> List[ParsedExpense]:

Find all money tokens (symboled, bare numbers, and k shorthand) with nearby category hints (±6 words; “uber/taxi/ride”→transport, “breakfast/coffee/lunch”→food, etc.).

Keep parse_expense() returning the first item (to preserve old callers).

In LOG handler:

If len(extract_all_expenses) == 0 → fallback as today

If >=1 → upsert each as a separate row using derived mids:

derived_mid = f"{mid}:{i}" for i=1..N

Single friendly reply summarizing:
✅ Logged: ৳2500 transport; ৳700 breakfast. Type 'summary' to review.

3) Corrections: robust and always on

Files: handlers/expense.py, parsers/expense.py

Keep correction algorithm:

Candidate = latest uncorrected expense within 10 min (prefer matching category/merchant)

Bare-number fallback for corrections (currency = user default if absent)

Supersede old row: set superseded_by, corrected_at, corrected_reason

Summaries exclude superseded_by IS NOT NULL

Reply:
Got it — corrected {category} from {old}{cur} → {new}{cur}.

4) Idempotency: standardize on (psid_hash, mid)

Files: utils/db.py, migrations

Ensure every insert/upsert passes psid_hash and mid (or mid:{i})

Migration (Postgres):

-- Add mid if missing (safe, nullable)
ALTER TABLE expenses ADD COLUMN IF NOT EXISTS mid TEXT;

-- Standard unique index (use psid_hash, not user_id)
DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM pg_indexes WHERE indexname='ux_expenses_user_mid') THEN
    DROP INDEX ux_expenses_user_mid;
  END IF;
END$$;

CREATE UNIQUE INDEX IF NOT EXISTS ux_expenses_psid_mid
  ON expenses(psid_hash, mid);

5) One source of truth for config (stop drift)

Files: utils/config.py (new)

Centralize all reads (env/kv). Router & worker import from here.

On process start, log a single line:

[CONFIG] version=always_on_v1 ai=on tone=on corrections=on

6) Telemetry & health

Files: utils/structured.py, finbrain/router.py

Emit structured logs for:

LOG_MULTI count=N derived_mids=[…]

CORRECTION_APPLIED old_id new_id

LOG_DUP (duplicate mid)

Per request banner (see §1)

Keep Graph API send logs as is.

7) Tests

Files: tests/test_stabilization.py (new), tests/test_corrections.py (ensure passing)

A. Multi-expense

Input: “Uber 2500 and breakfast 700”

Expect 2 rows, mids ...:1, ...:2, categories transport & food, one reply.

B. Correction bare number

“coffee 50” → “sorry, I meant 500”

Expect old.superseded_by=new.id; summary shows only 500.

C. Idempotency

Replay same FB mid → no new row; LOG_DUP emitted.

D. Router precedence

Ensure no legacy_money_detected path when AI available.

E. Summary exclusion

Superseded rows excluded from totals.

8) Dev verification script

File: scripts/verify_always_on.py

Runs end-to-end against local or staging:

Prints config banner read (always_on_v1)

Sends:

“Uber 2500 and breakfast 700” → expects 2 inserts, one reply

“sorry, I meant 500 for breakfast” → expects supersede

“summary” → checks totals exclude superseded row

Prints last 10 telemetry lines (router banner, LOG_MULTI, CORRECTION_APPLIED)

9) Acceptance checklist (print at end of tests & script)

 Router banner shows mode=AI and config_version=always_on_v1

 No legacy_money_detected logs

 Unique index ux_expenses_psid_mid exists

 Multi-expense inserts N rows with derived mids

 CORRECTION_APPLIED emitted and summaries exclude superseded rows

 Duplicate FB mid → no duplicate rows, LOG_DUP emitted

 Graph POSTs return 200 OK

Deliver back to me:

Files changed (one-liners for each)

Migration applied (yes/no)

Test results (pass counts)

Output of scripts/verify_always_on.py (last 10 telemetry lines)

Notes for launch:

Since flags are now removed and AI is always on, when you flip the Messenger “live” lever, features are on for everyone by default. If you later need a throttle, we can re-introduce a single RUN_MODE={staging|production} gate without per-PSID flags.