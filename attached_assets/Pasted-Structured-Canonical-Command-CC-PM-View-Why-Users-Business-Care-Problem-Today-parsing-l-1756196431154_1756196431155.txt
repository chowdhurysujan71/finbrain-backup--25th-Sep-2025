Structured Canonical Command (CC)
ğŸ¯ PM View â€” Why Users & Business Care

Problem: Today, parsing, logging, and replying are tightly coupled. If the system mis-parses once, itâ€™s hard to reproduce or explain why.

Solution: Every user message is converted into a single structured, standard object â€” the Canonical Command (CC). This becomes the source of truth for all downstream operations.

User Promise: â€œEvery decision is reproducible. You can always see what finbrain thought, what confidence it had, and what it did with your input.â€

Business Impact:

Auditability: You can replay any input months later and get the same decision.

Debuggability: Engineers and QA can inspect CC logs instead of tracing multiple systems.

Scalability: Enables SHADOW / DRYRUN / ON modes, because the same CC object flows through all.

Simple Example CC:

{
  "cc_id": "a1b2c3",
  "user_id": "user123",
  "intent": "LOG_EXPENSE",
  "slots": { "amount": 500, "currency": "BDT", "merchant_text": "Lunch" },
  "confidence": 0.92,
  "decision": "AUTO_APPLY",
  "source_text": "Lunch 500"
}

ğŸ›  CTO View â€” How We Implement Safely

Core Ledger Untouched: transactions_raw remains append-only, as today. Raw capture is still guaranteed.

Additive Only: The CC is persisted in a new or existing inference_snapshot table, without altering current tables.

Pipeline Re-architecture (lightweight):

Input â†’ Agent â†’ always emits a CC JSON.

Persist CC â†’ inference_snapshot (immutable log).

Downstream (router, overlay, UI) always consume from CC â€” not directly from parser.

Modes (safe experimentation):

SHADOW: CC is created + stored, but not used.

DRYRUN: CC drives raw write only, overlays untouched.

ON: CC drives overlays + UI.

FALLBACK: CC ignored, legacy flow runs.

This makes CC the switch point for all system behavior, while still letting you fall back to todayâ€™s pipeline instantly.

ğŸ§© Data Flow (Safe by Design)

User says: â€œBought groceries 1200 at Agora.â€

Agent emits CC (intent=LOG_EXPENSE, slots filled, confidence=0.88).

CC stored in inference_snapshot â†’ immutable record.

If PCA_MODE=ON:

Raw ledger row written (unchanged).

Effective overlay row written (if AUTO_APPLY).

UI note shown (â€œLogged à§³1200 groceries at Agoraâ€).

If PCA_MODE=SHADOW:

CC stored, but user still sees legacy flow.

Perfect for testing without user risk.

âš ï¸ Risk Controls

No core mutation: Raw ledger writes still happen the old way, CC just logs the interpretation.

Additive schema only: inference_snapshot is append-only; can drop without side effects.

Replay safety: Since CC contains schema_version + hash, old CCs remain valid even if schema evolves.

Rollback: Flip PCA_MODE=FALLBACK â†’ system ignores CC, reverts to todayâ€™s pipeline instantly.

ğŸš€ Why This is MVP-Critical

Trust: Users + auditors can always see â€œwhat the AI saw vs. what it did.â€

Control: Engineers can replay inputs safely in SHADOW/DRYRUN.

Scalability: Enables advanced features (clarifiers, audit UI, rules) to plug into one standard object.

Low Risk: Purely additive, flag-gated, with instant rollback.

âœ… In short:

PM pitch: â€œThe Canonical Command is the contract â€” every expense decision is reproducible, auditable, and explainable.â€

CTO pitch: â€œItâ€™s just an overlay log and a routing layer. The raw ledger stays intact, fallbacks are instant, and we gain SHADOW/DRYRUN/ON modes for free.â€