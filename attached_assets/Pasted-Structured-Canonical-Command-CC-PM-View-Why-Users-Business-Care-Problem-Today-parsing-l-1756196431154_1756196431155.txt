Structured Canonical Command (CC)
🎯 PM View — Why Users & Business Care

Problem: Today, parsing, logging, and replying are tightly coupled. If the system mis-parses once, it’s hard to reproduce or explain why.

Solution: Every user message is converted into a single structured, standard object — the Canonical Command (CC). This becomes the source of truth for all downstream operations.

User Promise: “Every decision is reproducible. You can always see what finbrain thought, what confidence it had, and what it did with your input.”

Business Impact:

Auditability: You can replay any input months later and get the same decision.

Debuggability: Engineers and QA can inspect CC logs instead of tracing multiple systems.

Scalability: Enables SHADOW / DRYRUN / ON modes, because the same CC object flows through all.

Simple Example CC:

{
  "cc_id": "a1b2c3",
  "user_id": "user123",
  "intent": "LOG_EXPENSE",
  "slots": { "amount": 500, "currency": "BDT", "merchant_text": "Lunch" },
  "confidence": 0.92,
  "decision": "AUTO_APPLY",
  "source_text": "Lunch 500"
}

🛠 CTO View — How We Implement Safely

Core Ledger Untouched: transactions_raw remains append-only, as today. Raw capture is still guaranteed.

Additive Only: The CC is persisted in a new or existing inference_snapshot table, without altering current tables.

Pipeline Re-architecture (lightweight):

Input → Agent → always emits a CC JSON.

Persist CC → inference_snapshot (immutable log).

Downstream (router, overlay, UI) always consume from CC — not directly from parser.

Modes (safe experimentation):

SHADOW: CC is created + stored, but not used.

DRYRUN: CC drives raw write only, overlays untouched.

ON: CC drives overlays + UI.

FALLBACK: CC ignored, legacy flow runs.

This makes CC the switch point for all system behavior, while still letting you fall back to today’s pipeline instantly.

🧩 Data Flow (Safe by Design)

User says: “Bought groceries 1200 at Agora.”

Agent emits CC (intent=LOG_EXPENSE, slots filled, confidence=0.88).

CC stored in inference_snapshot → immutable record.

If PCA_MODE=ON:

Raw ledger row written (unchanged).

Effective overlay row written (if AUTO_APPLY).

UI note shown (“Logged ৳1200 groceries at Agora”).

If PCA_MODE=SHADOW:

CC stored, but user still sees legacy flow.

Perfect for testing without user risk.

⚠️ Risk Controls

No core mutation: Raw ledger writes still happen the old way, CC just logs the interpretation.

Additive schema only: inference_snapshot is append-only; can drop without side effects.

Replay safety: Since CC contains schema_version + hash, old CCs remain valid even if schema evolves.

Rollback: Flip PCA_MODE=FALLBACK → system ignores CC, reverts to today’s pipeline instantly.

🚀 Why This is MVP-Critical

Trust: Users + auditors can always see “what the AI saw vs. what it did.”

Control: Engineers can replay inputs safely in SHADOW/DRYRUN.

Scalability: Enables advanced features (clarifiers, audit UI, rules) to plug into one standard object.

Low Risk: Purely additive, flag-gated, with instant rollback.

✅ In short:

PM pitch: “The Canonical Command is the contract — every expense decision is reproducible, auditable, and explainable.”

CTO pitch: “It’s just an overlay log and a routing layer. The raw ledger stays intact, fallbacks are instant, and we gain SHADOW/DRYRUN/ON modes for free.”