A) Single Source of Identity (hash once, carry through)
1) Centralize extraction + hashing
# utils/identity.py
import os, hashlib

ID_SALT = os.getenv("ID_SALT")
if not ID_SALT:
    raise RuntimeError("ID_SALT missing")

def extract_sender_psid(event: dict) -> str | None:
    # Only messages/postbacks create a user context
    m = event.get("entry", [{}])[0].get("messaging", [{}])[0]
    if "message" in m or "postback" in m:
        return m.get("sender", {}).get("id")
    return None  # delivery/read/etc.

def psid_hash(psid: str) -> str:
    return hashlib.sha256(f"{ID_SALT}|{psid}".encode()).hexdigest()

2) Webhook intake: compute once; do not re-hash later
# utils/webhook_processor.py (intake)
from utils.identity import extract_sender_psid, psid_hash

psid = extract_sender_psid(request.json)
if not psid:
    log.debug("Skipping non-message event")
    return "EVENT_RECEIVED", 200

h = psid_hash(psid)
job = {
    "mid": mid, "text": text,
    "psid": psid, "psid_hash": h,
    # anything else you need…
}
queue.put(job)
log.info('intake mid=%s psid_hash=%s text="%s"', mid, h, text[:120])

3) Background worker: trust the payload

Remove any utils.security.psid_hash(...) calls here. Use job["psid_hash"] everywhere (DB writes, summaries, replies).

4) Delivery/read events

Never hash/log identity for them. Your logs currently show b23a6a84… from delivery hooks; that muddies the water.

5) DB: key by psid_hash

Writes: INSERT INTO expenses (psid_hash, amount, category, note, created_at) ...

Reads (summary): WHERE psid_hash = :psid_hash AND created_at >= now() - interval '7 days'

Add helpful indexes:

CREATE INDEX IF NOT EXISTS idx_expenses_psidhash_created
ON expenses (psid_hash, created_at DESC);

CREATE UNIQUE INDEX IF NOT EXISTS idx_users_psidhash
ON users (psid_hash);

B) Kill the AI crash (“function has no len()”)
1) Normalize AI parse results
# ai/expense_parse.py
def parse_expense(text: str) -> dict:
    """
    Return {'amount': float, 'category': str, 'note': Optional[str]}
    Raise ValueError on bad parse.
    """
    result = _model_parse(text)              # your LLM adapter call

    # Defensive: unwrap callables and enforce types
    if callable(result): result = result()
    if not isinstance(result, dict):
        raise ValueError(f"AI parse returned {type(result)}")

    amt = result.get("amount")
    cat = result.get("category")
    note = result.get("note")

    if callable(amt): amt = amt()
    if callable(cat): cat = cat()
    if callable(note): note = note()

    if not isinstance(amt, (int, float, str)):
        raise ValueError("amount invalid")
    if isinstance(amt, str):
        amt = float(amt.replace(",", " ").split()[0])  # crude but safe

    if not isinstance(cat, str) or not cat.strip():
        raise ValueError("category missing/invalid")

    note = (note or "").strip() or None
    return {"amount": float(amt), "category": cat.strip(), "note": note}

2) Router: try AI → fallback regex → user hint
from ai.expense_parse import parse_expense
from utils.identity import psid_hash  # only if needed elsewhere

def handle_expense(job):
    mode = "AI"
    try:
        exp = parse_expense(job["text"])
    except Exception as e:
        logger.exception("AI expense logging error")
        mode = "STD"
        exp = regex_parse(job["text"])  # implement strict: ^spent (\d+(\.\d+)?) on ([a-z ]+)$
        if not exp:
            return send(job["psid"], f"I couldn't read that. Try: 'spent 200 on groceries'. | psid_hash={job['psid_hash']} | mode={mode}")

    db.save_expense(psid_hash=job["psid_hash"], **exp)
    return send(job["psid"], f"Logged {exp['amount']} on {exp['category']}. | psid_hash={job['psid_hash']} | mode={mode}")


The specific error “object of type 'function' has no len()” typically comes from:

Shadowing a symbol: tokens = tokens instead of tokens = tokens(...).

Returning a partial/closure and later doing len(result) or if len(errors).
The normalization above removes that entire class of bugs.

C) Add a 24-hour debug stamp to every outbound message

This instantly exposes identity and path.

import functools, os

DEBUG_MODE = os.getenv("FB_DEBUG_MODE", "1") == "1"

def stamp_reply(text, job, mode):
    if not DEBUG_MODE: return text
    return f"{text} | psid_hash={job['psid_hash']} | mode={mode}"

def send_reply(job, text, mode="STD"):
    msg = stamp_reply(text, job, mode)
    facebook_send_api(recipient_id=job["psid"], text=msg)
    logger.info("send_api ok | mode=%s | psid_hash=%s", mode, job["psid_hash"])


Use this in all reply paths (expense, summary, help, insights).