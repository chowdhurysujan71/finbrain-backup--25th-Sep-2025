Two hard checks (server-side)
A) Quickscan (confirms read/write use the same user_id)

Use your real PSID (the webhook prints it). Replace <PSID> with that raw ID:

curl -s "http://<YOUR_HOST>/ops/quickscan?psid=<PSID>" | jq .


You should see:

resolved_user_id: a 64-char hex

count ≥ 2

total ≥ 220

Run the same with the hash to confirm idempotency:

curl -s "http://<YOUR_HOST>/ops/quickscan?psid_hash=<64_HEX>" | jq .


Both calls must return the same resolved_user_id, count, and total.

B) Logs (confirms both paths align)

Tail logs and trigger summary once from Messenger:

# Replit shell
grep -E "TRACE .*user_id_resolved|TRACE .*record_expense|TRACE .*summary_query" -n runtime.log | tail -n 20


You want to see paired lines where user_id is identical for:

record_expense (write path)

summary_query (read path)

If anything’s off

If quickscan shows data but summary claims none → the summary function still has a legacy call site. Search and fix:

Find: get_user_expense_context or any function calling hash_psid(...) directly

Replace internal user id creation with ensure_hashed(psid or psid_hash)

Make sure callers pass psid= for raw IDs (FB webhook) and psid_hash= only for pre-hashed inputs

Final hardening (one-shot prompt for Replit AI)

Paste this to Replit AI to clean up and prevent regressions:

Prompt (paste all):

Finalize the hashing fix and prevent regressions.

Delete or deprecate legacy helpers that re-hash (e.g., hash_user_id); make utils/crypto.ensure_hashed the single entry point. Add:

# utils/crypto.py
def is_sha256_hex(s: str) -> bool: ...


In ALL read/write code paths (webhook handlers, conversational AI, admin tools, cron jobs), replace any direct hash_psid(...) use with:

user_id = ensure_hashed(psid or psid_hash)


Audit by grepping for hash_psid( and hash_user_id( and fix every call site.

Standardize field names:

Writes and reads must use user_id (64-hex). If user_id_hash exists, keep it as an alias but write and query via user_id only.

Strengthen tests:

Add a parametrized test that feeds both raw PSID and 64-hex to every public UserManager method and asserts identical results.

Add a regression test that fails if any function double-hashes a 64-hex.

Add a guard:

assert is_sha256_hex(user_id)


right before DB writes and reads (behind an env flag like STRICT_IDS=true).

Keep /ops/quickscan and the TRACE logs; document them in replit.md under “UAT & Debug”.

Run tests, show diffs, and paste the latest quickscan output for my PSID after logging two expenses. Ensure Messenger summary reflects the same totals.