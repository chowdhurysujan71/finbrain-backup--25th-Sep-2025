Quick verifications (no browser)

/redis-smoke → 200 with {"connected": true, "value": "ok"}

/readyz → 200 (now that Redis is reachable)

Minimal job round-trip:

# enqueue
curl -s -X POST https://YOUR_APP_URL/jobs \
  -H "X-User-ID: testuser" -H "Content-Type: application/json" \
  -d '{"type":"analysis","payload":{"ping":true},"idempotency_key":"demo-1"}'
# then poll status (replace JOB_ID)
curl -s https://YOUR_APP_URL/jobs/JOB_ID/status -H "X-User-ID: testuser"

Next: run Phase C UAT automatically

Paste this into the Replit AI Agent for finbrain-app. It will run a full UAT of the queue + retries + DLQ + breaker and write the report—no manual steps.

AGENT PROMPT — Run Phase C UAT (Queue, Retries, DLQ, Breaker)

You are my QA/UAT engineer. Execute UAT for Phase C end-to-end and produce evidence. Do not require a browser; run everything locally and print results.

Scope
- System already has /jobs, Redis queue, circuit breaker, Supabase mocks in tests.
- REDIS_URL is set. Do NOT modify production code except adding test hooks/mocks.

Tasks
1) Tests
- Create tests/test_phase_c_uat.py covering:
  a) Happy path: POST /jobs → job_id; worker processes; status → succeeded; result_path present.
  b) Retries: force AI 500s → 3 attempts with backoff (mock time) → DLQ entry.
  c) Idempotency: same idempotency_key returns same job_id.
  d) Rate limit: >60 jobs/hour for one user → 429 with Retry-After.
  e) Circuit breaker: trigger >5 failures/60s → breaker open; new enqueues 429; after 30s half-open probe; success closes.
  f) Redis down: simulate connection error → graceful 503 from POST /jobs and /jobs/status.
- Mock Supabase I/O to avoid external calls.
- Use redis/mocks or monkeypatch to simulate TTLs and counters; fast-forward time where needed.

2) Runner & Evidence
- Run pytest -q and capture output.
- After tests, start app locally and exercise:
  - POST /jobs (happy path) and poll status until terminal state (using test client or local HTTP).
- Print a concise summary:
  - Total tests, passed/failed, key metrics (p95 enqueue latency under test), breaker transitions observed.

3) Docs
- Write /docs/phase-c-uat-report.md including:
  - Test plan & scenarios
  - Pass/fail summary with snippets
  - Evidence of DLQ population and breaker open/close logs
  - Notes on /readyz now including Redis OK
- Ensure structured logs show job_id, request_id, user_id, attempts, latency_ms.

4) Acceptance
- All UAT tests pass.
- phase-c-uat-report.md created with evidence.
- Commit: test(phase-c): UAT for Redis queue, retries, DLQ, breaker + report


If /readyz still isn’t 200 after this, the usual culprits are: wrong REDIS_URL (REST URL instead of TCP rediss://…:6379), firewall/region mismatch, or missing TLS (rediss vs redis).