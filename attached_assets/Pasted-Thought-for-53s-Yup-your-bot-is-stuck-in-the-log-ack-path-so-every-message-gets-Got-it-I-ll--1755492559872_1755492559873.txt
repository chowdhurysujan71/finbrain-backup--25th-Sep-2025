Thought for 53s

Yup ‚Äî your bot is stuck in the ‚Äúlog-ack‚Äù path, so every message gets ‚ÄúGot it. I‚Äôll track that for you.‚Äù
Two things cause exactly this:

Worker import crash short-circuits the AI/rules path ‚Üí generic replies only.
Your logs already show: cannot import name 'user_manager'. Fix that first (as I outlined), or do a tactical local import inside the worker to unblock:

# utils/background_processor.py
def process_message(event):
    from utils.user_manager import user_manager  # tactical to break cycles
    ...


Intent routing order is wrong, so ‚ÄúSummary/Insight/How much‚Ä¶‚Äù are being treated as ‚Äúlog expense‚Äù (because there‚Äôs a number or the ‚Äúspent‚Äù keyword), returning the log ack template.

Here‚Äôs a 2-minute hotfix that fixes (2) and makes ‚ÄúSummary/Insight‚Äù work without AI (Stage-2 style).

1) Intent router: match commands before logging
# utils/intent_router.py
import re

RE_SUMMARY = re.compile(r'\b(summary|report|how much.*spen[dt]|total (this|for) (week|month)|spent so far)\b', re.I)
RE_INSIGHT = re.compile(r'\b(insight|tip|advice|recommend|optimi[sz]e)\b', re.I)
RE_LOG = re.compile(r'\b(spent|bought|paid|pay|\d+(?:\.\d{1,2})?\s*(bdt|tk|usd)?)\b', re.I)

def detect_intent(text: str) -> str:
    t = (text or "").strip()
    if RE_SUMMARY.search(t):   return "SUMMARY"   # case-insensitive
    if RE_INSIGHT.search(t):   return "INSIGHT"
    if RE_LOG.search(t):       return "LOG_EXPENSE"
    return "UNKNOWN"


Order matters: SUMMARY/INSIGHT must be checked before any ‚Äúspent/number‚Äù regex.

Wire it in your dispatcher so it doesn‚Äôt send the log ack if the intent is SUMMARY/INSIGHT.

2) Summary handler (DB, no AI)
# handlers/summary.py
from datetime import datetime, timezone
from dateutil.relativedelta import relativedelta
from utils.db import db

def month_bounds(now=None, tz=timezone.utc):
    now = now or datetime.now(tz)
    start = now.replace(day=1, hour=0, minute=0, second=0, microsecond=0)
    if start.month == 12:
        end = start.replace(year=start.year+1, month=1)
    else:
        end = start.replace(month=start.month+1)
    return start, end

def handle_summary(user_id: str) -> dict:
    start, end = month_bounds()
    rows = db.fetch_all(
        """
        SELECT category, SUM(amount) AS total, COUNT(*) AS n
        FROM expenses
        WHERE user_id=%s AND created_at >= %s AND created_at < %s
        GROUP BY category
        ORDER BY total DESC
        """,
        (user_id, start, end)
    )
    total = sum(r["total"] for r in rows) if rows else 0
    top = rows[0]["category"] if rows else "‚Äî"
    top_amt = rows[0]["total"] if rows else 0
    entries = sum(r["n"] for r in rows) if rows else 0

    msg = (
        f"üìä This month so far: {total:.0f} BDT across {entries} entries.\n"
        f"Top category: {top} ({top_amt:.0f}).\n"
        f"Tip: type 'insight' for a quick read on what to optimize."
    )
    return {"text": msg}


Ensure your dispatcher sends this message when intent == "SUMMARY".

3) Deterministic ‚Äúinsight‚Äù (no AI required)
# handlers/insight.py
from utils.db import db
from .summary import month_bounds

def handle_insight(user_id: str) -> dict:
    start, end = month_bounds()
    rows = db.fetch_all(
        "SELECT category, SUM(amount) AS total FROM expenses "
        "WHERE user_id=%s AND created_at >= %s AND created_at < %s "
        "GROUP BY category ORDER BY total DESC",
        (user_id, start, end)
    )
    total = sum(r["total"] for r in rows) or 0
    if not total:
        return {"text": "No spend logged yet this month. Log a few expenses first."}

    lines = []
    for r in rows[:4]:
        pct = (r["total"]/total)*100
        lines.append(f"‚Ä¢ {r['category']}: {r['total']:.0f} ({pct:.0f}%)")

    # simple rules
    alerts = []
    for r in rows:
        pct = (r["total"]/total)*100
        if r["category"].lower() in {"groceries","food"} and pct > 30:
            alerts.append("Groceries >30% ‚Äî plan a 10% cut with a weekly list.")
        if r["category"].lower() in {"ride","transport","uber"} and pct > 20:
            alerts.append("Transport >20% ‚Äî try batching trips or off-peak times.")

    msg = "üß† Quick insights:\n" + "\n".join(lines)
    if alerts:
        msg += "\n\n‚ö†Ô∏è Suggestions:\n" + "\n".join(f"‚Ä¢ {a}" for a in alerts)
    else:
        msg += "\n\n‚úÖ Nice balance. Keep it up!"
    return {"text": msg}

4) Parser for multi-amount messages (your ‚ÄúUber 100 + shoe 500‚Äù case)
# utils/parser.py
import re

AMOUNT = r'(\d+(?:\.\d{1,2})?)'
CURRENCY = r'(?:\s*(?:bdt|tk|usd))?'
ITEM = r'(?:on|for)?\s*([a-z ]{0,30})'

def extract_expenses(text):
    t = text.lower()
    # find all numbers; try to attach a nearby noun as category hint
    nums = re.findall(AMOUNT + CURRENCY, t)
    cats = []
    if "grocery" in t or "grocer" in t: cats.append("Groceries")
    if "uber" in t or "ride" in t or "transport" in t: cats.append("Transport")
    if "shoe" in t: cats.append("Shopping")
    # fallback category per number when hints run out
    out = []
    for i, n in enumerate(nums):
        cat = cats[i] if i < len(cats) else "Uncategorized"
        out.append({"amount": float(n[0]), "category": cat})
    return out


Use this in the LOG handler to insert both amounts instead of only the first.

5) Dispatcher (make the fallback last)
# utils/dispatcher.py
from utils.intent_router import detect_intent
from handlers.summary import handle_summary
from handlers.insight import handle_insight
from handlers.logger import handle_log  # your existing logger

def handle_event(user_id, text):
    intent = detect_intent(text)
    if intent == "SUMMARY":
        return handle_summary(user_id)
    if intent == "INSIGHT":
        return handle_insight(user_id)
    if intent == "LOG_EXPENSE":
        return handle_log(user_id, text)
    return {"text": "I didn‚Äôt catch that. Try: ‚Äòsummary‚Äô, ‚Äòinsight‚Äô, or ‚ÄòI spent 500 on groceries‚Äô."}

6) Don‚Äôt rate-limit non-AI paths

If you have a per-minute AI cap, apply it only when you call the AI. The SUMMARY/INSIGHT above are deterministic and should bypass the AI limiter.

if intent in {"SUMMARY","INSIGHT"}:
    return handler(...)  # no AI limiter
if intent_uses_ai(intent):
    check_ai_limiter_or_fallback()

7) Quick UAT (copy/paste)

Send (in order):
Spent 120 on groceries ‚Üí ack
Spent another 100 on Uber and then bought a shoe for 500 ‚Üí two rows added
How much did I spend this month so far ‚Üí summary text
Summary ‚Üí summary text
Insight ‚Üí insight bullets + suggestions

If any of those still return the log-ack, your router is returning early in the LOG branch. Search for any return send_ack(...) that executes before the intent switch and move it into the LOG handler only.