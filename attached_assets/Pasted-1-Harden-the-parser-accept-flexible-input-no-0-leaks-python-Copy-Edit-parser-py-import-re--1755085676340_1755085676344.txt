1) Harden the parser (accept flexible input, no “.0 ” leaks)
python
Copy
Edit
# parser.py
import re

BN_MAP = str.maketrans("০১২৩৪৫৬৭৮৯", "0123456789")
CURRENCY = r"[৳$€£₹]"

AMOUNT = r"(?P<amt>\d{1,3}(?:,\d{3})*(?:\.\d{1,2})?|\d+(?:\.\d{1,2})?)"
NOTE   = r"(?P<note>.+?)"

LOG_PATTERNS = [
    rf"^(?:log|spent|add)\s+{CURRENCY}?\s*{AMOUNT}\s+{NOTE}$",   # log 250 lunch / log ৳250 lunch
    rf"^{CURRENCY}?\s*{AMOUNT}\s+{NOTE}$",                      # 250 lunch / ৳250 lunch
    rf"^{NOTE}\s+{CURRENCY}?\s*{AMOUNT}$",                      # lunch 250 / lunch ৳250
]

ZERO_WIDTH = r"[\u200B-\u200D\u2060]"

def _clean_text(s:str)->str:
    s = (s or "").translate(BN_MAP)
    s = re.sub(ZERO_WIDTH, "", s)
    s = re.sub(r"\s+", " ", s).strip()
    return s

def _clean_amount(s:str)->float:
    s = re.sub(CURRENCY, "", s)
    s = s.replace(",", "")
    return round(float(s), 2)

def parse_expense(msg:str):
    t = _clean_text(msg)
    for pat in LOG_PATTERNS:
        m = re.match(pat, t, flags=re.IGNORECASE)
        if not m: 
            continue
        amt_str = m.group("amt")
        note    = m.group("note").strip(" .-—_/\\|")
        # Guard: if note accidentally starts with a lone decimal fragment like ".0"
        note = re.sub(r"^\.(?:0|00)\b\s*", "", note)  # kills ".0 " prefix safely
        if not note:
            note = "misc"
        return _clean_amount(amt_str), note
    return None  # no match
Why “.0 coffee” happened
Typical cause is splitting tokens then rejoining (e.g., " ".join(parts[1:])) after converting amount → leaving the ‘.0’ decimal tail in the note. The regex approach above never mutates the note from split math; it extracts fields cleanly and strips any leading “.0 ” if it ever slips in.

Supported inputs now:

log 250 lunch, spent 120 taxi gulshan, ৳300 groceries, 300 groceries, groceries 300, ডিনার ৪৫০, add $12.50 snacks

2) One-time cleanup for existing rows
sql
Copy
Edit
-- Remove zero-width chars, trim, collapse spaces
UPDATE expenses
SET description = regexp_replace(
      regexp_replace(
        regexp_replace(description, '[\u200B-\u200D\u2060]', '', 'g'),
        '\s+', ' ', 'g'
      ),
      '^\s+|\s+$', '', 'g'
    )
WHERE description IS NOT NULL;

-- Strip accidental currency in description
UPDATE expenses
SET description = regexp_replace(description, '[৳$€£₹]', '', 'g')
WHERE description ~ '[৳$€£₹]';

-- Kill the specific ".0 " leak at the start of description
UPDATE expenses
SET description = regexp_replace(description, '^\.(?:0|00)\b\s*', '', 'g')
WHERE description ~ '^\.(?:0|00)\b';
3) Safer INSERT path (backend)
python
Copy
Edit
# worker.py snippet
parsed = parse_expense(incoming_text)
if parsed:
    amt, note = parsed
    category = infer_category(note)  # your rule map
    db.execute(
        "INSERT INTO expenses (user_id, amount, description, category, platform) "
        "VALUES (%s, %s, %s, %s, %s)",
        (user_id, amt, note, category, platform)
    )
    # reply as needed…
else:
    # reply with help or summary path
4) Guardrails in DB (future-proof)
sql
Copy
Edit
ALTER TABLE expenses
  ALTER COLUMN created_at SET DEFAULT NOW();

-- Keep description non-empty
ALTER TABLE expenses
  ALTER COLUMN description SET NOT NULL,
  ALTER COLUMN description SET DEFAULT 'misc';

-- Optional: reject leading dot-decimal artifacts at write time
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_trigger WHERE tgname = 'tr_expense_desc_sanitize'
  ) THEN
    CREATE OR REPLACE FUNCTION expense_desc_sanitize()
    RETURNS trigger AS $f$
    BEGIN
      NEW.description := regexp_replace(NEW.description, '^\.(?:0|00)\b\s*', '', 'g');
      NEW.description := regexp_replace(NEW.description, '[\u200B-\u200D\u2060]', '', 'g');
      NEW.description := regexp_replace(NEW.description, '\s+', ' ', 'g');
      NEW.description := btrim(NEW.description);
      IF NEW.description = '' THEN NEW.description := 'misc'; END IF;
      RETURN NEW;
    END;
    $f$ LANGUAGE plpgsql;

    CREATE TRIGGER tr_expense_desc_sanitize
    BEFORE INSERT OR UPDATE ON expenses
    FOR EACH ROW EXECUTE FUNCTION expense_desc_sanitize();
  END IF;
END$$;
5) Dashboard showing “static” numbers (bind to live API)
Make sure you’re not rendering hardcoded placeholders. Wire to a tiny stats endpoint and re-render on load.

Backend:

python
Copy
Edit
@app.get("/api/stats")
def api_stats():
    uid = get_current_user_id()  # your auth
    row = db.fetch_one("""
      WITH t AS (
        SELECT
          COALESCE(SUM(amount) FILTER (WHERE created_at::date = CURRENT_DATE),0) AS today,
          COALESCE(SUM(amount) FILTER (WHERE created_at >= CURRENT_DATE - INTERVAL '7 days'),0) AS d7,
          COALESCE(SUM(amount) FILTER (WHERE created_at >= CURRENT_DATE - INTERVAL '30 days'),0) AS d30
        FROM expenses WHERE user_id = %s
      ),
      top AS (
        SELECT category, SUM(amount) total
        FROM expenses
        WHERE user_id = %s AND created_at >= CURRENT_DATE - INTERVAL '30 days'
        GROUP BY category ORDER BY total DESC LIMIT 5
      ),
      recent AS (
        SELECT created_at, description, category, amount, platform
        FROM expenses WHERE user_id = %s
        ORDER BY created_at DESC LIMIT 10
      )
      SELECT
        (SELECT row_to_json(t) FROM t) AS totals,
        (SELECT json_agg(top) FROM top) AS top,
        (SELECT json_agg(recent) FROM recent) AS recent;
    """, (uid, uid, uid))
    return {
      "today": row["totals"]["today"],
      "d7":    row["totals"]["d7"],
      "d30":   row["totals"]["d30"],
      "top":   row["top"] or [],
      "recent":row["recent"] or [],
    }
Frontend (replace any mock):

js
Copy
Edit
async function loadStats() {
  const r = await fetch("/api/stats", { credentials: "include" });
  const d = await r.json();
  setText("#todayTotal", formatBDT(d.today));
  setText("#weekTotal",  formatBDT(d.d7));
  setText("#monthTotal", formatBDT(d.d30));
  renderRecent(d.recent);
}

function setText(sel, txt){ const el = document.querySelector(sel); if(el) el.textContent = txt; }
function formatBDT(n){ return `৳${Number(n).toLocaleString(undefined, {minimumFractionDigits:2, maximumFractionDigits:2})}` }

function renderRecent(items){
  const tbody = document.querySelector("#recentBody");
  if(!tbody) return;
  tbody.innerHTML = items.map(it => `
    <tr>
      <td>${new Date(it.created_at).toLocaleString()}</td>
      <td>${escapeHtml(it.description)}</td>
      <td>${escapeHtml(it.category || "—")}</td>
      <td>${formatBDT(it.amount)}</td>
      <td>${escapeHtml(it.platform || "—")}</td>
    </tr>
  `).join("");
}
function escapeHtml(s){return (s??"").replace(/[&<>"']/g, m=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;" }[m]));}

document.addEventListener("DOMContentLoaded", loadStats);