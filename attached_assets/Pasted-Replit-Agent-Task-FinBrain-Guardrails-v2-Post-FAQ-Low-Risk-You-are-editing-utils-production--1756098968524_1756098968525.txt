Replit Agent Task ‚Äî FinBrain Guardrails v2 (Post-FAQ, Low-Risk)

You are editing:

utils/production_router.py

utils/ai_adapter_v2.py

utils/ux_copy.py (new)

utils/ttl_store.py (new)

tests/test_guardrails.py (new)

HARD CONSTRAINTS

Do not rename/move existing files or change handler/dispatcher contracts.

Keep the core flow: Limiter ‚Üí RL-2 (if limited) ‚Üí AI (if enabled) ‚Üí Rules (fallback).

Injection point: Run guardrails only AFTER FAQ returns no match, BEFORE any AI work.

Feature flags default OFF. Owner bypass via ENV (no hard-coded IDs).

Owner (bypass):

Raw PSID: 30522114904098519

Hashed PSID: a20425ef‚Ä¶16ff (optional; if empty, only raw PSID is used‚Äîthis avoids the ‚Äúincomplete hash‚Äù pitfall you raised).

Environment (minimal):

FEATURE_BURST_LIMIT=true|false
FEATURE_DAILY_CAP=true|false
FEATURE_PII_FILTER=true|false
FEATURE_ANTI_REPEAT=true|false
OWNER_PSID=30522114904098519
OWNER_PSID_HASH=a20425ef‚Ä¶16ff   # optional; leave empty if unknown
DAILY_CAP_LIMIT=30
BURST_LIMIT_MAX=5
BURST_LIMIT_WINDOW_SECONDS=10
REDIS_URL=<optional>

PART 1 ‚Äî UX copy (centralized)

Create: utils/ux_copy.py

# utils/ux_copy.py
SLOW_DOWN = "‚ö†Ô∏è You‚Äôre sending messages very fast‚Äîplease slow down."
DAILY_LIMIT = "‚è≥ You‚Äôve reached today‚Äôs limit of 30 messages. Please come back tomorrow."
REPEAT_HINT = "Got that‚Äîanything new you‚Äôd like me to do now: log, summary, or insight?"
PII_WARNING = "üîí For your security, please don‚Äôt share sensitive information here."
BUSY = "‚è≥ FinBrain is a bit busy right now. Please try again in a few minutes."
FALLBACK = ("üß≠ I can help you log expenses, show summaries, or share insights. "
            "Try: ‚Äòcoffee 120‚Äô or ‚Äòsummary this week‚Äô. For details visit www.finbrain.app")

PART 2 ‚Äî Messaging guardrail prompt (UX polish; zero-risk)

Edit: utils/ai_adapter_v2.py

# utils/ai_adapter_v2.py
MESSAGING_GUARDRAIL_PROMPT = (
    "You are FinBrain, a friendly financial companion in chat. Be natural and supportive, not robotic. "
    "One reply per message; keep it short (2‚Äì4 sentences, ‚â§280 chars). Use 0‚Äì2 emojis max "
    "(üßæ logging, üìä reports, üí° insights, üîí security, üß≠ fallback). "
    "Avoid repeating the same phrase within a short window; vary phrasing. "
    "Ask one clarifying question if needed; end with one clear next step. "
    "Never ask for or echo card numbers, passwords, or personal identifiers."
)

def _compose_system_prompt(self, base_prompt: str) -> str:
    return f"{MESSAGING_GUARDRAIL_PROMPT}\n\n{base_prompt}"


(Ensure you call _compose_system_prompt(...) where you send the system prompt.)

PART 3 ‚Äî Lightweight TTL store (Redis preferred; safe fallback)

Create: utils/ttl_store.py

# utils/ttl_store.py
import os, time, threading
from typing import Optional

class InProcTTL:
    def __init__(self):
        self._d = {}
        self._lock = threading.Lock()
    def _purge(self):
        now = time.time()
        drop = [k for k,(_,exp) in self._d.items() if exp and exp < now]
        for k in drop: self._d.pop(k, None)
    def incr(self, key: str, ttl_seconds: Optional[int] = None) -> int:
        with self._lock:
            self._purge()
            val, exp = self._d.get(key, (0, 0))
            val += 1
            if ttl_seconds: exp = time.time() + ttl_seconds
            self._d[key] = (val, exp)
            return val
    def get(self, key: str):
        with self._lock:
            self._purge()
            itm = self._d.get(key)
            return itm[0] if itm else None
    def setex(self, key: str, ttl_seconds: int, value: int = 1):
        with self._lock:
            self._purge()
            self._d[key] = (value, time.time() + ttl_seconds)
    def exists(self, key: str) -> bool:
        with self._lock:
            self._purge()
            return key in self._d

def get_store():
    url = os.getenv("REDIS_URL")
    if not url:
        return InProcTTL()
    import redis  # type: ignore
    client = redis.Redis.from_url(url)
    class RedisTTL:
        def incr(self, key: str, ttl_seconds: Optional[int] = None) -> int:
            p = client.pipeline()
            p.incr(key)
            if ttl_seconds and (client.ttl(key) is None or client.ttl(key) < 0):
                p.expire(key, ttl_seconds)
            return p.execute()[0]
        def get(self, key: str):
            v = client.get(key)
            return int(v) if v else None
        def setex(self, key: str, ttl_seconds: int, value: int = 1):
            client.setex(key, ttl_seconds, value)
        def exists(self, key: str) -> bool:
            return bool(client.exists(key))
    return RedisTTL()

PART 4 ‚Äî Guardrail middleware (placed after FAQ)

Edit: utils/production_router.py

Add imports:

import os, re, time, datetime, hashlib
from utils.ttl_store import get_store
from utils.ux_copy import SLOW_DOWN, DAILY_LIMIT, REPEAT_HINT, PII_WARNING
from utils.faq_map import match_faq_or_smalltalk  # ensure FAQ runs first


Store instance (module-level or in __init__):

STORE = get_store()


Helpers:

def _is_owner(psid: str, psid_hash: str) -> bool:
    env_psid = os.getenv("OWNER_PSID")
    env_hash = os.getenv("OWNER_PSID_HASH")  # optional
    return (psid and env_psid and psid == env_psid) or (psid_hash and env_hash and psid_hash == env_hash)

def _utc_seconds_until_midnight() -> int:
    now = datetime.datetime.utcnow()
    tomorrow = now + datetime.timedelta(days=1)
    midnight = datetime.datetime(tomorrow.year, tomorrow.month, tomorrow.day)
    return int((midnight - now).total_seconds())

_CARD_RE = re.compile(r"(?:\D|^)(\d{13,19})(?:\D|$)")
_PASS_RE = re.compile(r"\b(pass(word)?|pin|otp)\b", re.I)

def _hash_text(text: str) -> str:
    # robust, collision-safe: exact MD5 of full text; avoids ‚Äúcoffee 120‚Äù vs ‚Äúcoffee 100‚Äù collisions
    return hashlib.md5(text.encode("utf-8")).hexdigest()


In your main handler, keep your existing FAQ fast-path first:

# 0) FAQ fast-path (keep blazingly fast; no guardrails here)
det = match_faq_or_smalltalk(user_text)
if det:
    return det


Then insert the guardrail gate (BEFORE AI work):

def _guardrail_after_faq(self, psid: str, psid_hash: str, text: str):
    # Owner bypass
    if _is_owner(psid, psid_hash):
        return None

    # Flags
    burst_on = os.getenv("FEATURE_BURST_LIMIT", "false").lower() == "true"
    daily_on = os.getenv("FEATURE_DAILY_CAP", "false").lower() == "true"
    pii_on   = os.getenv("FEATURE_PII_FILTER", "false").lower() == "true"
    rep_on   = os.getenv("FEATURE_ANTI_REPEAT", "false").lower() == "true"

    # 1) Burst limiter (e.g., 5 msgs / 10s)
    if burst_on:
        window = int(os.getenv("BURST_LIMIT_WINDOW_SECONDS", "10"))
        maxn   = int(os.getenv("BURST_LIMIT_MAX", "5"))
        cnt = STORE.incr(f"burst:{psid}", ttl_seconds=window)
        if cnt > maxn:
            return SLOW_DOWN

    # 2) Daily cap (e.g., 30/day; TTL ‚Üí UTC midnight)
    if daily_on:
        today = datetime.datetime.utcnow().strftime("%Y%m%d")
        dkey = f"daily:{psid}:{today}"
        if not STORE.exists(dkey):
            STORE.setex(dkey, _utc_seconds_until_midnight(), 0)
        cnt = STORE.incr(dkey)
        limit = int(os.getenv("DAILY_CAP_LIMIT", "30"))
        if cnt > limit:
            return DAILY_LIMIT

    # 3) PII light filter
    if pii_on and ( _CARD_RE.search(text) or _PASS_RE.search(text) ):
        return PII_WARNING

    # 4) Anti-repeat (exact match, 45s window ‚Äî not 120s; lowers false negatives without annoying users)
    if rep_on:
        rep_key = f"repeat:{psid}"
        h = _hash_text(text or "")
        last = STORE.get(rep_key)
        if last and str(last) == h:
            STORE.setex(rep_key, 45, last)  # refresh the window
            return REPEAT_HINT
        STORE.setex(rep_key, 45, h)

    return None


Call it right after the FAQ block, before AI/dispatcher:

try:
    gate = self._guardrail_after_faq(psid=user_psid, psid_hash=user_psid_hash, text=user_text)
    if gate:
        return gate
except Exception:
    # Graceful failure: never block the user if guardrails have an issue
    pass


This fixes your #1 blocker: FAQ remains instant and never hits rate caps. Guardrails only run on non-FAQ traffic.

Performance note: This path is 3‚Äì4 simple key ops + 1 regex pair + MD5 (fast). With Redis it‚Äôs typically <5ms; with in-proc it‚Äôs microseconds. You also asked for monitoring‚Äîsee UAT/Report.

PART 5 ‚Äî Tests (building blocks)

Create: tests/test_guardrails.py

from utils.ttl_store import get_store
from utils.ux_copy import SLOW_DOWN, DAILY_LIMIT, REPEAT_HINT, PII_WARNING

def test_store_ttl():
    s = get_store()
    k = "x:ttl"
    v1 = s.incr(k, ttl_seconds=1)
    assert v1 == 1
    import time; time.sleep(1.1)
    assert s.get(k) in (None, 0)

def test_copy_strings():
    assert "slow" in SLOW_DOWN.lower()
    assert "limit" in DAILY_LIMIT.lower()
    assert "security" in PII_WARNING.lower()
    assert "anything new" in REPEAT_HINT.lower()


(End-to-end router tests can be added later; this keeps it non-disruptive.)

UAT ‚Äî Manual (focus on your concerns)

Setup

Flags ON: FEATURE_BURST_LIMIT=true, FEATURE_DAILY_CAP=true, FEATURE_PII_FILTER=true, FEATURE_ANTI_REPEAT=true

Owner ENV set: OWNER_PSID=30522114904098519 (hash optional)

Deploy to your Reserved VM.

Steps

FAQ fast-path unaffected

Send what is finbrain rapidly 6√ó ‚Üí always get the FAQ answer instantly (no SLOW_DOWN / no DAILY_LIMIT).

Burst limiter (non-FAQ)

From a non-owner PSID, send 6 different non-FAQ lines in 10s ‚Üí get exactly one SLOW_DOWN; the next message after 10s processes normally.

Daily cap (non-FAQ)

From a fresh non-owner PSID, send 31 non-FAQ messages in the same UTC day ‚Üí 31st gets DAILY_LIMIT; further messages the same day produce no more copies (or at most once/hour if you choose).

Reset

After UTC midnight (or simulate) ‚Üí same PSID can send again (cap reset).

PII warning

Paste a 16-digit number or ‚Äúmy password is 1234‚Äù ‚Üí receive exactly one PII_WARNING (content not echoed).

Anti-repeat (45s)

Send exact same non-FAQ text twice within 45s ‚Üí second gets REPEAT_HINT.

Send ‚Äúcoffee 120‚Äù then ‚Äúcoffee 100‚Äù ‚Üí no repeat hint (MD5 differs; this fixes your hash collision concern).

Owner bypass

From 30522114904098519 ‚Üí never see SLOW_DOWN or DAILY_LIMIT; all flows normal.

Latency spot-check

Compare FAQ latency before/after ‚Üí should remain ~1ms.

Non-FAQ latency overhead target: < 10 ms (Redis) / ~1‚Äì2 ms (in-proc).

Pass Criteria

FAQ never rate-limited.

Guardrails trigger only on non-FAQ traffic.

No false positives on anti-repeat (‚Äú120‚Äù vs ‚Äú100‚Äù).

No crashes; expense logging/summaries/insights behave normally.

Owner bypass respected.

End-of-Run Report (fill after UAT)

Build: <commit>
Env: Reserved VM (0.5 vCPU / 2 GiB)
Date (UTC+6): <YYYY-MM-DD>
Tester: <name>

Summary

‚úÖ Injection point fixed (post-FAQ, pre-AI).

‚úÖ Burst limiter (5/10s) working; no FAQ impact.

‚úÖ Daily cap (30/day) with UTC midnight reset.

‚úÖ PII regex warning active.

‚úÖ Anti-repeat (MD5, 45s) avoids collisions.

‚úÖ Owner bypass via ENV.

‚úÖ No regressions in logging/summaries/insights.

Metrics (spot)

Avg FAQ latency: <X ms> (unchanged)

Avg non-FAQ overhead: <Y ms>

Burst hits/day: <n> | Daily caps/day: <n> | PII warns/day: <n>

Issues

<none / list> with severity & repro

Go/No-Go

GO / NO-GO ‚Äî Sign-off: <name>